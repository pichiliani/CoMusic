<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GTBase</name>
    </assembly>
    <members>
        <member name="T:GT.HPTimer">
            <summary>A high-resolution high-performance timer.  The time is stable, only updated
            when explicitly commanded.
            </summary>
        </member>
        <member name="T:GT.IStartable">
            <summary>
            Defines methods for starting, stopping, and disposing of an instance.
            A stopped instance may be started again.  A disposed instance can never
            be restarted.  A stopped instance can be stopped multiple times.
            To properly support IDisposable, an instance can be disposed whether it
            is started or stopped.
            </summary>
        </member>
        <member name="M:GT.IStartable.Start">
            <summary>
            Start the instance.  Starting an instance may throw an exception on error.
            </summary>
        </member>
        <member name="M:GT.IStartable.Stop">
            <summary>
            Stop the instance.  Instances can be stopped multiple times.
            Stopping an instance may throw an exception on error.
            </summary>
        </member>
        <member name="P:GT.IStartable.Active">
            <summary>
            Return true if the instance is currently active.
            </summary>
        </member>
        <member name="M:GT.HPTimer.#ctor">
            <summary>A high-resolution high-performance timer.</summary>
        </member>
        <member name="M:GT.HPTimer.Start">
            <summary>Starts the timer timing.</summary>
        </member>
        <member name="M:GT.HPTimer.Update">
            <summary>Updates the current values of the timer.</summary>
        </member>
        <member name="M:GT.HPTimer.StartNew">
            <summary>
            Create a new, started instance.
            </summary>
            <returns>a new, started instance</returns>
        </member>
        <member name="P:GT.HPTimer.Frequency">
            <summary>This timer ticks this many times per second.
            This is a measure of how accurate this timer is on this particular machine.</summary>
        </member>
        <member name="P:GT.HPTimer.ElapsedInSeconds">
            <summary>A measure of how many seconds have passed
            between the last two calls of the method Update.</summary>
        </member>
        <member name="P:GT.HPTimer.ElapsedInMilliseconds">
            <summary>A measure of how many milliseconds have passed
            between the last two calls of the method Update.</summary>
        </member>
        <member name="P:GT.HPTimer.Ticks">
            <summary>A measure of how many timer ticks have passed in total
            between the the creation of this object and the last call of Update.</summary>
        </member>
        <member name="P:GT.HPTimer.TimeInSeconds">
            <summary>A measure of how many seconds have passed in total
            between the the creation of this object and the last call of Update.</summary>
        </member>
        <member name="P:GT.HPTimer.TimeInMilliseconds">
            <summary>A measure of how many milliseconds have passed in total
            between the the creation of this object and the last call of Update.</summary>
            <remarks>A long should be able to represent 584942417 years worth of milliseconds.</remarks>
        </member>
        <member name="T:GT.Net.BaseTransport">
            <summary>
            
            </summary>
            <remarks>
            <see cref="M:GT.Net.BaseTransport.NotifyPacketSent(GT.Net.TransportPacket)"/> and <see cref="M:GT.Net.BaseTransport.NotifyPacketReceived(GT.Net.TransportPacket)"/> 
            will ensure that the packet is disposed after the callbacks have been
            issued.  Listeners wishing to hold onto the packet should call
            <see cref="M:GT.Net.TransportPacket.Retain"/>.
            </remarks>
        </member>
        <member name="T:GT.Net.ITransport">
            <remarks>
            Represents a connection to either a server or a client.
            Errors should be notified by throwing a <see cref="T:GT.Net.TransportError"/>;
            warnings and recovered errors are notified through the <see cref="E:GT.Net.ITransport.ErrorEvent"/>.
            Transports are responsible for disposing of any <see cref="T:GT.Net.TransportPacket"/>
            instances provided to <see cref="M:GT.Net.ITransport.SendPacket(GT.Net.TransportPacket)"/>.
            <see cref="T:GT.Net.TransportPacket"/> instances provided through the <see cref="E:GT.Net.ITransport.PacketSent"/>
            and <see cref="E:GT.Net.ITransport.PacketReceived"/> are disposed of upon the completion of the
            callback, and thus only have a lifetime of the callback
            unless they are first attached to using <see cref="M:GT.Net.TransportPacket.Retain"/>.
            </remarks>
        </member>
        <member name="T:GT.Net.ITransportDeliveryCharacteristics">
            <summary>
            An interface describing the delivery characteristics of a transport.
            </summary>
        </member>
        <member name="P:GT.Net.ITransportDeliveryCharacteristics.Reliability">
            <summary>
            Are packets sent using this transport guaranteed to reach the other side?
            </summary>
        </member>
        <member name="P:GT.Net.ITransportDeliveryCharacteristics.Ordering">
            <summary>
            Are packets sent using this transport received in the same order on the other side?
            </summary>
        </member>
        <member name="P:GT.Net.ITransportDeliveryCharacteristics.Delay">
            <summary>
            Return or update the observed delay on the transport (in milliseconds).
            When setting, the implementation may smooth the value.
            This property does not introduce nor control introduced delay.
            </summary>
        </member>
        <member name="P:GT.Net.ITransportDeliveryCharacteristics.MaximumPacketSize">
            <summary>
            The maximum packet size supported by this transport instance (in bytes).
            </summary>
        </member>
        <member name="M:GT.Net.ITransport.SendPacket(GT.Net.TransportPacket)">
            <summary>
            Send the given packet to the server.  This transport will call
            <see cref="M:GT.Net.TransportPacket.Dispose"/> once completed.
            </summary>
            <param name="packet">the packet to send</param>
            <exception cref="T:GT.Net.TransportError">thrown on a fatal transport error.</exception>
        </member>
        <member name="M:GT.Net.ITransport.Update">
            <summary>
            Process any events pertaining to this instance; also flushes any 
            backlogged outgoing packets.
            </summary>
            <exception cref="T:GT.Net.TransportError">thrown on a fatal transport error.</exception>
        </member>
        <member name="P:GT.Net.ITransport.Name">
            <summary>
            A simple identifier for this transport.  This name should uniquely identify this
            transport.
            </summary>
        </member>
        <member name="P:GT.Net.ITransport.Active">
            <summary>
            Is this instance active?
            </summary>
        </member>
        <member name="P:GT.Net.ITransport.Backlog">
            <summary>
            How many packets are backlogged waiting to be sent?
            </summary>
        </member>
        <member name="E:GT.Net.ITransport.PacketReceived">
            <summary>
            An event triggered on receiving an incoming packet.
            The <see cref="T:GT.Net.TransportPacket"/> instance generally only has a 
            lifetime of the callback; be sure to first call <see cref="M:GT.Net.TransportPacket.Retain"/>
            to reference the packet beyond the callback.
            </summary>
        </member>
        <member name="E:GT.Net.ITransport.PacketSent">
            <summary>
            An event triggered having sent a packet.
            The <see cref="T:GT.Net.TransportPacket"/> instance generally only has a 
            lifetime of the callback; be sure to first call <see cref="M:GT.Net.TransportPacket.Retain"/>
            to reference the packet beyond the callback.
            </summary>
        </member>
        <member name="E:GT.Net.ITransport.ErrorEvent">
            <summary>
            Raised to notify of warnings or recovered errors arising from the use of
            this transport.  Unrecoverable errors are indicated by <see cref="T:GT.Net.TransportError"/>.
            Primarily used for indicating that the instance has become backlogged.
            different transports handle backlog differently; reports with
            <see cref="F:GT.Severity.Information"/> generally indicates that the packet was
            be queued or buffered to be resent on subsequent calls to <see cref="M:GT.Net.ITransport.SendPacket(GT.Net.TransportPacket)"/>
            and <see cref="M:GT.Net.ITransport.Update"/>;  <see cref="F:GT.Severity.Warning"/> generally indicates that 
            the packet has been discarded.
            </summary>
        </member>
        <member name="P:GT.Net.ITransport.Capabilities">
            <summary>
            A set of tags describing the capabilities of the transport and of expectations/capabilities
            of the users of this transport.
            </summary>
        </member>
        <member name="P:GT.Net.ITransport.MaximumPacketSize">
            <summary>
            The maximum packet size supported by this transport instance (in bytes).
            Particular transports may enforce a cap on this value.
            </summary>
        </member>
        <member name="F:GT.Net.BaseTransport.delay">
            <summary>The average amount of latency between this server 
            and the client (in milliseconds).</summary>
        </member>
        <member name="F:GT.Net.BaseUdpTransport.DefaultMaximumMessageSize">
            <summary>
            Allow setting a cap on the maximum UDP message size
            as compared to the OS value normally used.
            512 is the historical value supported by GT.
            </summary>
        </member>
        <member name="F:GT.Net.BaseUdpTransport.UDP_MAXDGRAMSIZE">
            <summary>
            Theoretical maximum of a UDP datagram size as UDP length field is 16 bits.
            But some systems apparently cap a datagram at 8K.
            </summary>
        </member>
        <member name="M:GT.Net.BaseUdpTransport.WritePacketHeader(GT.Net.TransportPacket)">
            <summary>
            Provide an opportunity to subclasses to write out the packet header
            </summary>
            <param name="packet"></param>
        </member>
        <member name="P:GT.Net.BaseUdpTransport.MaximumPacketSize">
            <summary>
            Set the maximum packet size allowed by this transport.
            Although UDP theoretically allows datagrams up to 64K in length
            (since its length field is 16 bits), some systems apparently
            cap a datagram at 8K.  So the general recommendation
            is to use 8K or less.
            </summary>
        </member>
        <member name="T:GT.Utils.DataConverter">
            <summary>
            <see cref="T:System.BitConverter"/> is sadly not endiannes-agnostic
            (e.g., http://blogs.msdn.com/robunoki/archive/2006/04/05/568737.aspx).
            Although the Mono project does provide a very featureful Mono.DataConverter
            (http://mono-project.com/Mono_DataConvert), it's a bit too featureful,
            bordering on unwieldy, and also requires compilation with /unsafe.
            </summary>
        </member>
        <member name="T:GT.Utils.DataConverter.CopyConverter">
            <summary>
            The CopyConverter simply defers to <see cref="T:System.BitConverter"/>.
            </summary>
        </member>
        <member name="M:GT.GTException.#ctor(GT.Severity)">
            <summary>
            Initializes a new instance of the System.Exception class.
            </summary>
        </member>
        <member name="M:GT.GTException.#ctor(GT.Severity,System.String)">
            <summary>
            Initializes a new instance of the System.Exception class with a specified error message.
            </summary>
            <param name="sev">the severity of the exception</param>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:GT.GTException.#ctor(GT.Severity,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the System.Exception class with a specified error message
            and inner exception.
            </summary>
            <param name="sev">the severity of the exception</param>
            <param name="message">The message that describes the error.</param>
            <param name="inner">the cause of the exception, if any</param>
        </member>
        <member name="P:GT.Net.CannotSendMessagesError.IsApplicable">
            <summary>
            Return true if this exception has had errors associated with it.
            </summary>
        </member>
        <member name="T:GT.Net.CannotConnectException">
            <summary>
            Represents an error situation where a connection cannot be established for
            some reason.
            </summary>
            <remarks>
            This class is serializable to support GT-Millipede,
            though the deserialized form may not correspond directly
            if some of the relevant objects are not themselves serializable.
            </remarks>
        </member>
        <member name="T:GT.Net.NoMatchingTransport">
            <summary>
            No transport could be found that supports the required quality-of-service specifications.
            Unsendable may contain the list of messages.
            </summary>
        </member>
        <member name="T:GT.Net.ConnexionClosedException">
            <summary>
            An internal exception indicating that the connexion has been closed by the remote side.
            </summary>
        </member>
        <member name="T:GT.Net.TransportError">
            <summary>
            Indicates some kind of fatal error that cannot be handled by the underlying
            system object.  The underlying system object is not in a useable state.
            Catchers have the option of restarting / reinitializing the
            underlying system object.
            </summary>
            <remarks>
            This class is serializable to support GT-Millipede,
            though the deserialized form may not correspond directly
            if some of the relevant objects are not themselves serializable.
            </remarks>
        </member>
        <member name="T:GT.Net.IMarshaller">
            <remarks>
            A marshaller is responsible for transforming an object to a sequence of bytes,
            and later restoring an equivalent object from that sequence of bytes.
            GT marshallers must handle strings, session objects, byte arrays, and tuples.
            Marshaller implementations have special responsibilities with regards to
            handling the <see cref="T:GT.Net.TransportPacket"/> instances used for storing the
            marshalling results, which are documented in the method comments.
            </remarks>
        </member>
        <member name="M:GT.Net.IMarshaller.Marshal(System.Int32,GT.Net.Message,GT.Net.ITransportDeliveryCharacteristics)">
            <summary>
            Marshal the provided message in an appropriate form for the provided transport.
            Returns the results as a list of <see cref="T:GT.Net.TransportPacket"/> instances,
            as encoded in a <see cref="T:GT.Net.IMarshalledResult"/>.  It is the caller's
            responsibility to ensure the <see cref="T:GT.Net.IMarshalledResult"/> is properly
            disposed of using <see cref="!:IMarshalledResult.Dispose"/>.
            Although it is also the caller's responsibility to separately dispose of 
            these packets (through <see cref="M:GT.Net.TransportPacket.Dispose"/>), this 
            responsibility is typically transferred once these packets are sent 
            across an <see cref="T:GT.Net.ITransport"/>. 
            Unless the marshaller has support for fragmenting a message across
            multiple packets, the marshaller should not perform any checks
            that the resulting packet fits within the 
            <see cref="P:GT.Net.ITransportDeliveryCharacteristics.MaximumPacketSize"/>.
            </summary>
            <param name="senderIdentity">the server-unique id of the sender of this message
            (i.e., the local client or server's server-unique identifier).  This
            should generally be the same number across different invocations.</param>
            <param name="message">the message</param>
            <param name="tdc">the characteristics of the transport on which the packet 
                will be sent; this may be the actual transport</param>
            <returns>the marshalled result, containing a set of transport packets;
                this result <b>must</b> be disposed of with <see cref="!:IMarshalledResult.Dispose"/>
                once finished with</returns>
            <exception cref="T:GT.Net.MarshallingException">on a marshalling error</exception>
        </member>
        <member name="M:GT.Net.IMarshaller.Unmarshal(GT.Net.TransportPacket,GT.Net.ITransportDeliveryCharacteristics,System.EventHandler{GT.Net.MessageEventArgs})">
            <summary>
            Unmarshal one message (or possibly more) as encoded in the transport-specific 
            form from <see cref="!:input"/>.   Messages are notified using the provided 
            <see cref="!:messageAvailable"/> delegate; a message may not be immediately 
            available, for example, if decoding their byte-content depends on information 
            carried in a not-yet-seen message.  The marshaller <b>must</b> destructively 
            modify the packet to remove the bytes consituting the message; this it typically 
            done using either <see cref="M:GT.Net.TransportPacket.RemoveBytes(System.Int32,System.Int32)"/> or 
            <see cref="M:GT.Net.TransportPacket.AsReadStream"/>.  Should the marshaller require 
            access to the contents of <see cref="!:input"/> after this call has returned
            then the marshaller should request for a subset of the packet using
            <see cref="M:GT.Net.TransportPacket.Subset(System.Int32,System.Int32)"/>.
            </summary>
            <param name="input">the stream with the packet content</param>
            <param name="tdc">the characteristics of transport from which the packet was 
                received; this may be the actual transport</param>
            <param name="messageAvailable">a callback for when a message becomes available
            from the stream.</param>
        </member>
        <member name="M:GT.Net.IMarshaller.IsCompatible(System.String,GT.Net.ITransport)">
            <summary>
            Return true if this marshaller can handle the marshalling format
            defined by the provided marshaller descriptor.
            </summary>
            <param name="marshallingDescriptor"></param>
            <param name="remote">the remote transport</param>
            <returns>true if this marshaller can handle messages marshalled in the
            described format, or false otherwise</returns>
        </member>
        <member name="P:GT.Net.IMarshaller.Descriptor">
            <summary>
            Returns a string identifying this marshaller's capabilities.
            The descriptor should not have any white-space.  This descriptor is
            provided to the remote marshaller to assess whether there is any common
            ground using <see cref="M:GT.Net.IMarshaller.IsCompatible(System.String,GT.Net.ITransport)"/>.
            
            For now, marshallers should only return a single descriptor.
            </summary>
        </member>
        <member name="T:GT.Net.IMarshalledResult">
            <summary>
            A representation of a marshalled message.  The instance should
            have its <see cref="!:Dispose"/> called when finished with.
            </summary>
            <summary>
            A representation of a marshalled message.  The instance should
            have its <see cref="!:Dispose"/> called when finished with.
            </summary>
        </member>
        <member name="M:GT.Net.IMarshalledResult.RemovePacket">
            <summary>
            Remove the next packet.  Return null if there is no packet available;
            this does not necessarily entail that there are no more packets
            (i.e., that this instance is <see cref="P:GT.Net.IMarshalledResult.Finished"/>).
            </summary>
            <returns></returns>
        </member>
        <member name="E:GT.Net.IMarshalledResult.Disposed">
            <summary>
            Triggered when the marshalled result instance has been instructed
            to be disposed.
            </summary>
        </member>
        <member name="P:GT.Net.IMarshalledResult.HasPackets">
            <summary>
            Does this instance have packets *at this moment*?
            This is different from having exhausted all available packets.
            </summary>
            <seealso cref="P:GT.Net.IMarshalledResult.Finished"/>
        </member>
        <member name="P:GT.Net.IMarshalledResult.Finished">
            <summary>
            Are there any packets remaining from this instance?
            </summary>
        </member>
        <member name="T:GT.Net.MarshalledResult">
            <summary>
            A simple <see cref="T:GT.Net.IMarshalledResult"/> implementation for
            marshallers returning a fixed-number of packets.  Not intended
            for marshallers that may produce very long sequences of packets,
            such as something that is streaming out a large number of bytes.
            </summary>
        </member>
        <member name="P:GT.Net.MarshalledResult.Packets">
            <summary>
            Return the list of remaining packets
            </summary>
        </member>
        <member name="T:GT.Net.MessageEventArgs">
            <summary>
            Represents the event information from a message becoming available.
            Some marshallers may choose to subclass this to provide additional information.
            </summary>
        </member>
        <member name="P:GT.Net.MessageEventArgs.Transport">
            <summary>
            The transport on which this message was received.
            </summary>
        </member>
        <member name="P:GT.Net.MessageEventArgs.Message">
            <summary>
            The message received
            </summary>
        </member>
        <member name="T:GT.Net.MarshallingException">
            <summary>
            An exception thrown in case of a error or warning during marshalling or unmarshalling.
            </summary>
        </member>
        <member name="T:GT.Net.LWMCFv11">
            <summary>
            Support utilities for the Lightweight Message Container Format 1.1.
            (aka LWMCFv1.1).
            </summary>
        </member>
        <member name="F:GT.Net.LWMCFv11.Descriptor">
            <summary>
            Descriptor for the Lightweight Message Container Format v1.1:
            This format prefix each marshaller with a 6 byte header where:
            <list>
            <item> byte 0 is the message type</item>
            <item> byte 1 is the channelId</item>
            <item> bytes 2-6 encode the message data length using the 
                <see cref="!:DataConverter.Converter.GetBytes(uint)"/> format.</item>
            </list>
            </summary>
        </member>
        <member name="F:GT.Net.LWMCFv11.HeaderSize">
            <summary>
            The # bytes in the v1.1 header.
            </summary>
        </member>
        <member name="M:GT.Net.LWMCFv11.EncodeHeader(GT.Net.MessageType,System.Byte,System.UInt32)">
            <summary>
            Encode a v1.1 compliant header.
            </summary>
            <returns>the header bytes</returns>
        </member>
        <member name="M:GT.Net.LWMCFv11.EncodeHeader(GT.Net.MessageType,System.Byte,System.UInt32,System.IO.Stream)">
            <summary>
            Encode a v1.1 compliant header.
            </summary>
        </member>
        <member name="T:GT.Net.BaseLWMCFMarshaller">
            <summary>
            A basic framework for implementing marshallers adhering to the
            Lightweight Message Container Format v1.1.
            </summary>
        </member>
        <member name="M:GT.Net.BaseLWMCFMarshaller.Marshal(System.Int32,GT.Net.Message,GT.Net.ITransportDeliveryCharacteristics)">
            <summary>
            Marshal the given message to the provided stream in a form suitable to
            be sent out on the provided transport.
            </summary>
            <param name="senderIdentity">the identity of the sender</param>
            <param name="msg">the message being sent, that is to be marshalled</param>
            <param name="tdc">the characteristics of the transport that will send the marshalled form</param>
            <returns>the marshalled representation</returns>
        </member>
        <member name="M:GT.Net.BaseLWMCFMarshaller.MarshalContents(GT.Net.Message,System.IO.Stream,GT.Net.ITransportDeliveryCharacteristics)">
            <summary>
            Marshal the contents of the message <see cref="!:m"/> onto the stream <see cref="!:output"/>.
            The channelId and message type have already been placed on <see cref="!:output"/>.
            This method is **not responsible** for encoding the message payload length.
            </summary>
            <param name="m">the message contents to be marshalled</param>
            <param name="output">the destination for the marshalled message payload</param>
            <param name="tdc">the characteristics of the transport that is to be used for sending</param>
        </member>
        <member name="M:GT.Net.BaseLWMCFMarshaller.UnmarshalContent(System.Byte,GT.Net.MessageType,System.IO.Stream,System.UInt32)">
            <summary>
            Unmarshal the content from the provided stream.  The message payload was marshalled as
            <see cref="!:length"/> bytes, is of type <see cref="!:type"/>, and is intended for 
            <see cref="!:channelId"/>.
            </summary>
            <param name="channelId">the channelId received on</param>
            <param name="type">the type of message</param>
            <param name="input">the marshalled contents</param>
            <param name="length">the number of bytes available</param>
            <returns>the unmarshalled message or null if the contents could not be unmarshalled</returns>
        </member>
        <member name="T:GT.Net.DotNetSerializingMarshaller">
            <summary>
            A standard-issue marshaller that marshals strings, byte arrays, and objects.
            Strings are marshalled as UTF-8, byte arrays are marshalled as-is, and objects
            are marshalled using the .NET Serialization framework.
            </summary>
        </member>
        <member name="T:GT.Net.LightweightDotNetSerializingMarshaller.RawMessage">
            <summary>
            An uninterpreted, length-prefixed message
            </summary>
        </member>
        <member name="T:GT.Net.Message">
            <remarks>A base GT message.</remarks>
        </member>
        <member name="M:GT.Net.Message.#ctor(System.Byte,GT.Net.MessageType)">
            <summary>Creates a new outbound message.</summary>
            <param name="channelId">The channel carrying this message.</param>
            <param name="type">The type of message.</param>
        </member>
        <member name="P:GT.Net.Message.ChannelId">
            <summary>The channel carrying this message.</summary>
        </member>
        <member name="P:GT.Net.Message.MessageType">
            <summary>The type of message.</summary>
        </member>
        <member name="P:GT.Net.LightweightDotNetSerializingMarshaller.RawMessage.Bytes">
            <summary>The binary byte content.</summary>
        </member>
        <member name="T:GT.Millipede.MillipedeMode">
            <summary>
            Determines the mode of the millipede debugger:
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeMode.Unconfigured">
            <summary>
             Recorder is currently unconfigured
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeMode.Record">
            <summary>
             Writes incoming and outgoing network traffic to a file
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeMode.Playback">
            <summary>
             Injects recorded network traffic from a file
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeMode.PassThrough">
            <summary>
            Bypass Millipede entirely.
            </summary>
        </member>
        <member name="T:GT.Millipede.MillipedeRecorder">
            <summary>
            A recorder is able to record or replay a stream of <see cref="T:GT.Millipede.MillipedeEvent"/>.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeRecorder.ConfigurationEnvironmentVariableName">
            <summary>
            The name of the environment variable used by GT-Millipede for
            configuration of the singleton instance.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeRecorder.uniqueCount">
            <summary>
            Used for allocating stable but unique descriptors for recordable objects.
            For example, two TcpConnectors have no distinguishing characteristics;
            we can't use their ToString() as they'll be identical.  So we instead
            increment this value as necessary.  As long as the app's execution path
            is stable, then we'll allocate the same descriptors in the same order
            during playback as was allocated for the recording run.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeRecorder.nextEvent">
            <summary>
            The next event to release during playback.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeRecorder.nextEventReleaseTime">
            <summary>
            The time in milliseconds when <see cref="F:GT.Millipede.MillipedeRecorder.nextEvent"/> *should* be released,
            as opposed to the timestamp in its timestamp, <see cref="P:GT.Millipede.MillipedeEvent.Time"/>.
            This value helps replay events as according to the logical time: <see cref="F:GT.Millipede.MillipedeRecorder.timer"/>,
            being an instance of <see cref="T:System.Diagnostics.Stopwatch"/>, is based on wall-clock, and hence
            will be thrown off by delays introduced from debugging, such as stepping into
            a function.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeRecorder.NumberEvents">
            <summary>
            Return the number of events replayed or recordered to this point.
            </summary>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.#ctor">
            <summary>
            Create an instance of a Millipede recorder/replayer.  It is generally
            expected that mmode developers will use the singleton instance
            <see cref="P:GT.Millipede.MillipedeRecorder.Singleton"/>.
            </summary>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.GenerateDescriptor(System.Object)">
            <summary>
            Generate a unique descriptor for the provided object.
            This method assumes the object's <see cref="M:GT.Millipede.MillipedeRecorder.ToString"/> is 
            stable (i.e., it will produce the same value on subsequent
            runs when configured the same way).
            For the descriptor to be stable, this method must be called
            with the same objects and in the same order.
            This method assumes that it is called once per object;
            do not call this method multiple times for the same object.
            </summary>
            <param name="obj">the object needing a descriptor</param>
            <returns>a unique descriptor for the provided object</returns>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.CheckReplayEvent(System.Object,GT.Millipede.MillipedeEventType[])">
            <summary>
            Check if the next event waiting is for the recordable object identified 
            as <see cref="!:descriptor"/>.  The next event is properly delayed to
            match the recorded session.
            </summary>
            <param name="descriptor"></param>
            <param name="expected">the expected event types; if specified, used to log
                a warning if an unexpected event type is found</param>
            <returns>the next event for the recordable object, or null if there is no
            such event waiting</returns>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.WaitForReplayEvent(System.Object,GT.Millipede.MillipedeEventType[])">
            <summary>
            Check and wait for the next event waiting for the recordable object identified 
            as <see cref="!:descriptor"/>.  The next event is properly delayed to
            match the recorded session.
            </summary>
            <param name="descriptor">the descriptor</param>
            <param name="expected">the expected event types; if specified, used to log
                a warning if an unexpected event type is found</param>
            <returns>the event or null</returns>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.CheckForNotedDetails(System.Object)">
            <summary>
            Check if the next event waiting is a NotedDetail for the recordable object 
            identified  as <see cref="!:descriptor"/>.  The next event is properly delayed to
            match the recorded session.  Noted details are intended to record the
            results of some possible source of non-determinism to reproduce similar
            behaviour on playback, and thus a NotedDetail can be fetched before it
            was recorded.
            </summary>
            <param name="descriptor"></param>
            <returns>the next event for the recordable object, or null if there is no
            such event waiting</returns>
        </member>
        <member name="M:GT.Millipede.MillipedeRecorder.Configure(System.String)">
            <summary>
            Parse the provided configuration directive to configure this 
            instance.  Throw an exception if the directive is not parsable.
            Throw one of the many possible file-related exceptions on file error
            from  <see cref="M:System.IO.File.Create(System.String)"/>  (for "record:" directives) 
            and <see cref="M:System.IO.File.OpenRead(System.String)"/>  (for "play:" directives).
            </summary>
            <param name="envvar">the configuration directive</param>
            <seealso cref="M:System.IO.File.Create(System.String)"/>
            <seealso cref="M:System.IO.File.OpenRead(System.String)"/>
            <exception cref="T:System.ArgumentException">if the directive is unknown</exception>
            <exception cref="T:System.IO.FileNotFoundException">for play: of a non-existant file</exception>
        </member>
        <member name="P:GT.Millipede.MillipedeRecorder.Singleton">
            <summary>
            Return the singleton recorder instance.
            </summary>
        </member>
        <member name="T:GT.Millipede.MillipedeTransport">
            <summary>
            Wrapper class for any given GT.Net.ITransport
            </summary>
            <see cref="T:GT.Net.ITransport"/>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport.#ctor(GT.Net.ITransport,GT.Millipede.MillipedeRecorder,System.Object)">
            <summary>
            Creates a recording wrapper for any given ITransport
            </summary>
            <param name="underlyingTransport">The underlying <see cref="T:GT.Net.ITransport"/></param>
            <param name="recorder">Millepede recorder</param>
            <param name="milliTransportDescriptor">the Millipede descriptor for <see cref="F:GT.Millipede.MillipedeTransport.underlyingTransport"/></param>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport.#ctor(GT.Millipede.MillipedeRecorder,System.Object,System.String,System.Collections.Generic.IDictionary{System.String,System.String},GT.Net.Reliability,GT.Net.Ordering,System.UInt32)">
            <summary>
            Creates a replaying wrapper for a former transport.
            </summary>
            <param name="recorder">Millepede recorder</param>
            <param name="milliTransportDescriptor">the millipede descriptor for this object</param>
            <param name="transportName">the <see cref="P:GT.Net.ITransport.Name"/></param>
            <param name="capabilities">the <see cref="P:GT.Net.ITransport.Capabilities"/></param>
            <param name="reliabilty">the <see cref="!:ITransport.Reliability"/></param>
            <param name="ordering">the <see cref="!:ITransport.Ordering"/></param>
            <param name="maxPacketSize">the <see cref="P:GT.Net.ITransport.MaximumPacketSize"/></param>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport._underlyingTransports_PacketSentEvent(GT.Net.TransportPacket,GT.Net.ITransport)">
            <summary>
            ITransports use a observer-pattern (implemented with events and callbacks) to notify
            other GT2 components. Since these other componets register to the MillipedeTransport,
            there must be a mechanism to forward notifications from the ITransport to other GT2
            components.
            </summary>
            <see cref="E:GT.Net.ITransport.PacketSent"/>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport._underlyingTransports_PacketReceivedEvent(GT.Net.TransportPacket,GT.Net.ITransport)">
            <summary>
            ITransports use a observer-pattern (implemented with events and callbacks) to notify
            other GT2 components. Since these other componets register to the MillipedeTransport,
            there must be a mechanism to forward notifications from the ITransport to other GT2
            components.
            </summary>
            <see cref="E:GT.Net.ITransport.PacketReceived"/>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport.SendPacket(GT.Net.TransportPacket)">
            <summary>
            Wraps ITransport.SendPacket(byte[],int,int). In addition, writes data to a sink if
            MillipedeTransport initialized with Mode.Record.
            </summary>
            <see cref="M:GT.Net.ITransport.SendPacket(GT.Net.TransportPacket)"/>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport.Update">
            <summary>
            Wraps ITransport.Update.
            </summary>
            <see cref="M:GT.Net.ITransport.Update"/>
        </member>
        <member name="M:GT.Millipede.MillipedeTransport.Dispose">
            <summary>
            Wraps ITransport.Dispose.
            </summary>
            <see cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Name">
            <summary>
            Wraps ITransport.Name.
            </summary>
            <see cref="P:GT.Net.ITransport.Name"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Backlog">
            <summary>
            Wraps ITransport.Backlog.
            </summary>
            <see cref="P:GT.Net.ITransport.Backlog"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Active">
            <summary>
            Wraps ITransport.Active.
            </summary>
            <see cref="P:GT.Net.ITransport.Active"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Reliability">
            <summary>
            Wraps ITransport.Reliability.
            </summary>
            <see cref="P:GT.Net.ITransportDeliveryCharacteristics.Reliability"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Ordering">
            <summary>
            Wraps ITransport.Ordering.
            </summary>
            <see cref="P:GT.Net.ITransportDeliveryCharacteristics.Ordering"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.MaximumPacketSize">
            <summary>
            Wraps ITransport.MaximumPacketSize.
            </summary>
            <see cref="P:GT.Net.ITransport.MaximumPacketSize"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Capabilities">
            <summary>
            Wraps ITransport.Capabilities.
            </summary>
            <see cref="P:GT.Net.ITransport.Capabilities"/>
        </member>
        <member name="P:GT.Millipede.MillipedeTransport.Delay">
            <summary>
            Wraps ITransport.Delay.
            </summary>
            <see cref="P:GT.Net.ITransportDeliveryCharacteristics.Delay"/>
        </member>
        <member name="T:GT.Millipede.MillipedeEventType">
            <summary>
            The event types that are recorded by Millipede.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Started">
            <summary>
            The object was started
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.PacketReceived">
            <summary>
            A packet was received by the obejct; contents are in the event's Message
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.SentPacket">
            <summary>
            A packet was sent by the obejct; contents are in the event's Message
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.NewClient">
            <summary>
            A new incoming connection was received; details in the event's Message
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Connected">
            <summary>
            The object connected to some remote; remote details are in the event's Message
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Exception">
            <summary>
            An exception was thrown; the exception is in the event's Context object
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Stopped">
            <summary>
            The object was stopped
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Disposed">
            <summary>
            The object was disposed
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Other">
            <summary>
            A generic catchall for other non-GT events.
            The event's Context object should record the necessary details.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.NotedDetails">
            <summary>
            Provided for other objects to note details during recording to avoid
            prompting users and avoiding causes of non-determinisms during playback.
            This is the only event that can be fetched before its scheduled time:
            see <see cref="M:GT.Millipede.MillipedeRecorder.CheckForNotedDetails(System.Object)"/>.
            The event's Context object should record the necessary details.
            </summary>
        </member>
        <member name="F:GT.Millipede.MillipedeEventType.Error">
            <summary>
            An error was detected; the Context is generally expected to be an
            <see cref="T:GT.Net.ErrorSummary"/>.
            </summary>
        </member>
        <member name="T:GT.Millipede.MillipedeEvent">
            <summary>
            Holds all necessary information about a millipede event.
            </summary>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.#ctor(System.Object,GT.Millipede.MillipedeEventType)">
            <summary>
            Creates a MillipedeEvent with null as Message.
            </summary>
            <param name="obj">the object descriptor generating this event</param>
            <param name="type">event type</param>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.#ctor(System.Object,GT.Millipede.MillipedeEventType,System.Byte[])">
            <summary>
            Creates a MillipedeEvent
            </summary>
            <param name="obj">the object descriptor generating this event</param>
            <param name="type">event type</param>
            <param name="message">associated data for the event</param>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.#ctor(System.Object,GT.Millipede.MillipedeEventType,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a MillipedeEvent
            </summary>
            <param name="obj">the object descriptor generating this event</param>
            <param name="type">event type</param>
            <param name="message">associated data for the event</param>
            <param name="offset">the offset of the bytes to store</param>
            <param name="count">the number of bytes of message to store</param>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.#ctor(System.Object,GT.Millipede.MillipedeEventType,System.Object)">
            <summary>
            Creates a MillipedeEvent, but with a context object instead of a message
            </summary>
            <param name="obj">the object descriptor generating this event</param>
            <param name="type">event type</param>
            <param name="context">associated context object for the event</param>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.Serialize(System.IO.Stream)">
            <summary>
            Serialize this object to a stream.
            </summary>
            <param name="sink">Target stream for serialization</param>
        </member>
        <member name="M:GT.Millipede.MillipedeEvent.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize an event from a stream.
            </summary>
            <param name="source">Source stream for deserialization</param>
            <returns>Deserialized NetworkEvent</returns>
        </member>
        <member name="P:GT.Millipede.MillipedeEvent.Time">
            <summary>
            The time of when this event occured, relative to the start of the
            recording.
            </summary>
        </member>
        <member name="P:GT.Millipede.MillipedeEvent.ObjectDescriptor">
            <summary>
            The descriptor of the object that raised this event
            </summary>
        </member>
        <member name="P:GT.Millipede.MillipedeEvent.Type">
            <summary>
            The type of this event
            </summary>
        </member>
        <member name="P:GT.Millipede.MillipedeEvent.Message">
            <summary>
            For those events that prefer to record a byte array instead of an object...
            </summary>
        </member>
        <member name="P:GT.Millipede.MillipedeEvent.Context">
            <summary>
            For those events that prefer to record an object instead of a message...
            </summary>
        </member>
        <member name="T:GT.Net.BinaryMessage">
            <summary>
            A GT message containing byte content.
            </summary>
        </member>
        <member name="M:GT.Net.BinaryMessage.#ctor(System.Byte,System.Byte[])">
            <summary>Creates a new outbound message.</summary>
            <param name="channelId">The channel carrying this message.</param>
            <param name="bytes">the contents</param>
        </member>
        <member name="P:GT.Net.BinaryMessage.Bytes">
            <summary>The binary byte content.</summary>
        </member>
        <member name="T:GT.Net.StringMessage">
            <summary>
            A GT message containing string content.
            </summary>
        </member>
        <member name="P:GT.Net.StringMessage.Text">
            <summary>The string text.</summary>
        </member>
        <member name="T:GT.Net.ObjectMessage">
            <summary>
            A GT message containing an object as content.
            </summary>
        </member>
        <member name="P:GT.Net.ObjectMessage.Object">
            <summary>The message's object.</summary>
        </member>
        <member name="T:GT.Net.SessionMessage">
            <summary>A message from a session about a particular client</summary>
        </member>
        <member name="M:GT.Net.SessionMessage.#ctor(System.Byte,System.Int32,GT.Net.SessionAction)">
            <summary>Create a new SessionMessage</summary>
            <param name="channelId">The channel carrying this message.</param>
            <param name="clientId">The subject of the session action.</param>
            <param name="e">The session action.</param>
        </member>
        <member name="P:GT.Net.SessionMessage.Action">
            <summary>What occurred on the session.</summary>
        </member>
        <member name="P:GT.Net.SessionMessage.ClientId">
            <summary>Which client was affected.</summary>
        </member>
        <member name="T:GT.Net.SystemMessage">
            <summary>
            A GT control message.  System messages aren't sent
            on a channel; the descriptor (the type of system message) is 
            instead encoded as the channelId.
            </summary>
        </member>
        <member name="M:GT.Net.SystemMessage.#ctor(GT.Net.SystemMessageType)">
            <summary>Create a new SystemMessage</summary>
        </member>
        <member name="P:GT.Net.SystemMessage.ChannelId">
            <summary>
            System messages aren't carried on a channel.  But some code assumes
            that all messages have a channelId.  So return a valid value.
            </summary>
        </member>
        <member name="P:GT.Net.SystemMessage.Descriptor">
            <summary>
            Return the system message descriptor.  System messages aren't sent
            on a channel; the descriptor is instead encoded as the channelId.
            </summary>
        </member>
        <member name="T:GT.Net.SystemPingMessage">
            <summary>
            A system message either requesting or responding to a ping.
            This is primarily intended for internal use.
            </summary>
        </member>
        <member name="T:GT.Net.SystemIdentityResponseMessage">
            <summary>
            A system message carrying a connexion's identity.
            </summary>
        </member>
        <member name="T:GT.Net.PendingMessage">
            <summary>
            Carries all the details necessary for sending a message.
            Not intended for public use.
            </summary>
        </member>
        <member name="T:GT.GMC.ShortcutsExhaustedException">
            <summary>
            The dictionary compressor is unable to capture the range required to
            encode the trie references.
            </summary>
        </member>
        <member name="F:GT.GMC.TrieCompressor.EscapeSingleCharacter">
            <summary>
            Indication of a single unencoded byte that should
            be included verbatim.  The byte should follow this indicator.
            </summary>
        </member>
        <member name="F:GT.GMC.TrieCompressor.EscapeMultipleCharacterSequence">
            <summary>
            Indication of a sequence of unencoded bytes that should
            be included verbatim.  Following this indicator is an encoded
            positive integer indicating the length of the sequence.
            </summary>
        </member>
        <member name="F:GT.GMC.TrieCompressor.announcements">
            <summary>
            Record how many shortcuts have been announced.
            </summary>
        </member>
        <member name="F:GT.GMC.TrieCompressor.lastAllocatedShortcut">
            <summary>
            The last allocated shortcut.  Shortcuts start at 3: 0 is used to indicate a 
            single-character escape, 1 for a many-character escape.
            </summary>
        </member>
        <member name="M:GT.GMC.TrieCompressor.Encode(System.Byte[])">
            <summary>
            Encode a message (a set of bytes) to a shorter representation by replacing sequences
            of bytes found in this instance's template by an index into the template-trie.
            These indices are remapped to a byte shortcut.
            </summary>
            <param name="message">the message to encode</param>
            <returns>the byte-encoded variant</returns>
        </member>
        <member name="M:GT.GMC.TrieCompressor.Decode(System.Byte[])">
            <summary>
            Decode a trie-based encoded message.
            </summary>
            <param name="encoded">the encoded bytes</param>
            <returns>the decoded bytes</returns>
        </member>
        <member name="M:GT.GMC.TrieCompressor.WriteShortcut(System.UInt32,System.IO.Stream)">
            <summary>
            Write the associated byte shortcut for an integer (used to map a trie code 
            to a byte)
            </summary>
            <param name="longForm">The full name of the trie</param>
            <param name="output">the destination for the byte</param>
            <returns>the associated byte shortcut</returns>
        </member>
        <member name="M:GT.GMC.TrieCompressor.HandleAnnouncement(System.UInt32,System.Byte)">
            <summary>
            Receive a dictionary update announcement
            </summary>
            <param name="longForm"></param>
            <param name="shortForm"></param>
        </member>
        <member name="M:GT.GMC.TrieCompressor.EncodedSize(System.Byte[])">
            <summary>
            Get an estimate of the size of the message as encoded with this template trie compressor.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:GT.Utils.StatisticalMoments">
             <summary>
             <para>A data structure representing the central moments of a distribution
             including:</para>
             <ul>
             <li> the mean </li>
             <li> the Variance </li>
             <li> the skewness</li>
             <li> the kurtosis </li>
             </ul>
             <para>Data values that are observed are passed into this data structure
             via the <see cref="M:GT.Utils.StatisticalMoments.Accumulate(System.Double)">Accumulate</see> method and the
             corresponding central moments are updated on each call.</para>
            
             <para>Author: Didier H. Besset (modified by Scott White)</para>
             </summary>
        </member>
        <member name="F:GT.Utils.StatisticalMoments.moments">
            <summary>
            Vector containing the points.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.#ctor">
            <summary>
            Default constructor methods: declare space for 5 moments.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.#ctor(System.Int32)">
            <summary>
            General constructor methods intended for subclasses needing
            more than 5 moments.  Implementors will need to modify
            <see cref="M:GT.Utils.StatisticalMoments.Accumulate(System.Double)">Accumulate()</see> in particular.
            </summary>
            <param name="n">number of moments to accumulate.</param>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Reset">
            <summary>
            Reset all counters.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Accumulate(System.Double)">
            <summary>
            Statistical moment accumulation up to order 4.
            </summary>
            <param name="x">value to accumulate</param>
            <remarks>Could override "+=" instead...</remarks>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Count">
            <summary>
            Returns the number of accumulated counts.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Average">
            <summary>
            Returns the average.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.ErrorOnAverage">
            <summary>
            Returns the error on average.
            May return NaN if there have not been sufficient number of
            values accumulated.
            </summary>
            <exception cref="T:System.DivideByZeroException">
            If no values have been accumulated.
            </exception>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Kurtosis">
            <summary>
            The kurtosis measures the sharpness of the distribution near
            the maximum.
            May return NaN if there have not been sufficient number of
            values accumulated.
            Note: The kurtosis of the Normal distribution is 0 by definition.
            Note: this is the estimator of the population kurtosis,
                and not the sample kurtosis.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Skewness">
            <summary>
            The skewness of the data.
            May return NaN if there have not been sufficient number of
            values accumulated.
            Note: this is the estimator of the population skewness,
                and not the sample skewness.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.StandardDeviation">
            <summary>
            Returns the standard deviation.
            May return NaN if there have not been sufficient number of
            values accumulated.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.UnnormalizedVariance">
            <summary>
            Returns the unormalized standard deviation.
            May return NaN if there have not been sufficient number of
            values accumulated.
            </summary>
        </member>
        <member name="M:GT.Utils.StatisticalMoments.Variance">
            <summary>
            Note: the Variance includes the Bessel correction factor.
            </summary>
        </member>
        <member name="T:GT.Utils.Returning`1">
            <summary>
            A delegate representing a method returning an instance of some type;
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:GT.Utils.Pool`1">
            <summary>
            A simple object pool for allocating and reusing objects.
            The pool maintains a minimum of <see cref="P:GT.Utils.Pool`1.Low"/> objects.
            If <see cref="P:GT.Utils.Pool`1.Strict"/>, then the pool will only allow a
            maximum of <see cref="P:GT.Utils.Pool`1.High"/> objects to be allocated; if
            false, then more are created upon demand.  Objects are
            requested from the pool by <see cref="M:GT.Utils.Pool`1.Obtain"/>, and returned
            once finished with via <see cref="M:GT.Utils.Pool`1.Return(`0)"/>; if a
            pool object has become ruined, it should be marked as
            such by calling <see cref="M:GT.Utils.Pool`1.Ruined(`0)"/>.
            
            <para>
            Simple pools differ from managed pools in that the 
            allocated pool elements are not explicitly tracked, and are
            not required to be returned to the pool.  Managed pools
            (such as <see cref="T:GT.Utils.ManagedPool`1"/> and <see cref="T:GT.Utils.StrictPool`1"/>)
            differ in that they require the allocated pool elements
            to be returned through <see cref="M:GT.Utils.Pool`1.Return(`0)"/> or <see cref="M:GT.Utils.Pool`1.Ruined(`0)"/>.
            </para>
            </summary>
            <typeparam name="T">the type of object</typeparam>
        </member>
        <member name="M:GT.Utils.Pool`1.#ctor(System.UInt32,System.UInt32,GT.Utils.Returning{`0},System.Action{`0},System.Action{`0})">
            <summary>
            Create a new managed object pool.  There should be a minimum of <see cref="!:low"/>
            and a maximum of <see cref="!:high"/> elements maintained by the pool.
            If <see cref="P:GT.Utils.Pool`1.Strict"/>, then these limits are strongly enforced;
            if not strict, then we create new elements as needed, though
            ensuring that excess elements are destroyed once returned.
            </summary>
            <param name="low">minimum number of instances to keep around</param>
            <param name="high">maximum number of instances to keep around</param>
            <param name="createBlock">delegate for creating new instances</param>
            <param name="rehabBlock">delegate for rehabilitating returned instances; can be null</param>
            <param name="destroyBlock">delegate for properly tearing down superfluous instances; can be null</param>
        </member>
        <member name="M:GT.Utils.Pool`1.Dispose">
            <summary>
            Dispose of this instance and destroy any elements managed by this pool.
            </summary>
        </member>
        <member name="M:GT.Utils.Pool`1.Copy">
            <summary>
            Make a replica of the receiver with its current settings.
            This does not copy the created elements associated with
            this instance. The copy will not be in a started state
            regardless of whether the receiver is started.
            </summary>
        </member>
        <member name="M:GT.Utils.Pool`1.Obtain">
            <summary>
            Obtain an element from the pool.  If there are no pool elements
            available, then a new element is created; this behaviour may be
            different in subclasses.
            Callers are requested to return the element when finished via
            <see cref="M:GT.Utils.Pool`1.Return(`0)"/> or <see cref="M:GT.Utils.Pool`1.Ruined(`0)"/>.
            </summary>
            <returns>an element from the pool</returns>
        </member>
        <member name="M:GT.Utils.Pool`1.TryObtain">
            <summary>
            Try to obtain an element from the pool if there are any available.
            Return <c>default(T)</c> if there are no pool elements immediately
            available.  This call should not block.
            </summary>
            <returns>a managed pool element, or <c>default(T)</c> if there are
                no pool elements available at this moment.</returns>
        </member>
        <member name="M:GT.Utils.Pool`1.Return(`0)">
            <summary>
            Return a previously-obtained pool element to the pool.
            </summary>
            <param name="poolElement">the element to return</param>
            <exception cref="T:System.ArgumentException">thrown if the provided
            pool element was not actually managed by this pool.</exception>
        </member>
        <member name="M:GT.Utils.Pool`1.Ruined(`0)">
            <summary>
            Return a previously-obtained element to the pool, but
            noting that the element has been ruined in some form
            and is not suitable for reuse; the element will be destroyed.
            </summary>
            <param name="poolElement">the ruined element</param>
            <exception cref="T:System.ArgumentException">thrown if the provided
            pool element was not actually managed by this pool.</exception>
        </member>
        <member name="M:GT.Utils.Pool`1.ToString(System.Collections.IEnumerable)">
            <summary>
            Helper method for pretty-printing
            </summary>
            <param name="collection">the collection to pretty-print</param>
            <returns>the result</returns>
        </member>
        <member name="P:GT.Utils.Pool`1.Low">
            <summary>
            The low water mark: this number is the minimum total number 
            of elements that should be managed by this pool.
            </summary>
        </member>
        <member name="P:GT.Utils.Pool`1.High">
            <summary>
            The high water mark: this number is the maximum total number 
            of elements that should be managed by this pool.  If <see cref="P:GT.Utils.Pool`1.Strict"/>
            is true, then this limit is strongly enforced; if false, then
            elements are created as demand warrants, but excess elements
            are destroyed once returned.
            </summary>
        </member>
        <member name="P:GT.Utils.Pool`1.Strict">
            <summary>
            If true, then this pool strongly enforces the minimum and maximum
            values (<see cref="P:GT.Utils.Pool`1.Low"/> and <see cref="P:GT.Utils.Pool`1.High"/>).
            </summary>
        </member>
        <member name="P:GT.Utils.Pool`1.Available">
            <summary>
            Return true if this pool has elements available to be obtained
            without blocking.
            </summary>
        </member>
        <member name="P:GT.Utils.Pool`1.Count">
            <summary>
            Return the number of elements managed by this pool.
            </summary>
        </member>
        <member name="P:GT.Utils.Pool`1.Out">
            <summary>
            Return the number of outstanding elements managed by this pool.
            </summary>
        </member>
        <member name="T:GT.Utils.ManagedPool`1">
            <summary>
            A managed pool build on a simple pool by also tracking
            the allocated objects.
            Unlike <see cref="T:GT.Utils.Pool`1">simple pools</see>, pool elements allocated
            from a managed pool are explicitly tracked, and are
            required to be returned to the pool through <see cref="M:GT.Utils.ManagedPool`1.Return(`0)"/> 
            or <see cref="M:GT.Utils.ManagedPool`1.Ruined(`0)"/>.  Instances that are not returned are
            lost which is not a good thing!
            </summary>
            <seealso cref="T:GT.Utils.Pool`1"/>
            <typeparam name="T">the object type managed by this pool</typeparam>
        </member>
        <member name="M:GT.Utils.ManagedPool`1.Obtain">
            <summary>
            Obtain an element from the pool.  If there are no pool elements
            available, then a new element is created; this behaviour may be
            different in subclasses.
            Callers are *required* to return the element when finished via
            <see cref="M:GT.Utils.ManagedPool`1.Return(`0)"/> or <see cref="M:GT.Utils.ManagedPool`1.Ruined(`0)"/>.
            </summary>
            <returns>an element from the pool</returns>
        </member>
        <member name="T:GT.Utils.StrictPool`1">
            <summary>
            A strict pool is a managed pool that strictly enforces the 
            high- and low-water marks.  A requestor is blocked 
            if there are no elements available.
            As with a <see cref="T:GT.Utils.ManagedPool`1">managed pool</see>, a
            strict pool also explicitly tracks the pool elements allocated,
            and are  required to be returned to the pool through <see cref="M:GT.Utils.StrictPool`1.Return(`0)"/> 
            or <see cref="M:GT.Utils.StrictPool`1.Ruined(`0)"/>.  Instances that are not returned are
            lost which is not a good thing!
            </summary>
            <seealso cref="T:GT.Utils.Pool`1"/>
            <seealso cref="T:GT.Utils.ManagedPool`1"/>
            <typeparam name="T">the object type managed by this pool</typeparam>
        </member>
        <member name="M:GT.Utils.StrictPool`1.#ctor(System.UInt32,System.UInt32,GT.Utils.Returning{`0},System.Action{`0},System.Action{`0})">
            <summary>
            Create a new strict managed object pool.  There should be a minimum of 
            <see cref="!:low"/> and a maximum of <see cref="!:high"/> elements maintained 
            by the pool. These limits are strongly enforced by this pool, such that
            requestors are blocked on <see cref="M:GT.Utils.StrictPool`1.Obtain"/> if there are no elements available.
            </summary>
            <param name="low">minimum number of instances to keep around</param>
            <param name="high">maximum number of instances to keep around</param>
            <param name="createBlock">delegate for creating new instances</param>
            <param name="rehabBlock">delegate for rehabilitating returned instances; can be null</param>
            <param name="destroyBlock">delegate for properly tearing down superfluous instances; can be null</param>
        </member>
        <member name="M:GT.Utils.StrictPool`1.Obtain">
            <summary>
            Obtain an element from the pool.
            The requestor is blocked if there are no elements available;
            this behaviour may be different in subclasses.
            Callers are *required* to return the element when finished via
            <see cref="M:GT.Utils.StrictPool`1.Return(`0)"/> or <see cref="M:GT.Utils.StrictPool`1.Ruined(`0)"/>.
            </summary>
            <returns>a pool element</returns>
        </member>
        <member name="P:GT.Utils.StrictPool`1.Available">
            <summary>
            Return true if this pool has elements available to be obtained
            without blocking.
            </summary>
        </member>
        <member name="T:GT.GMC.HuffmanEncodingTree">
            <summary>
            Simple implementation of a huffman encoding tree.  A tree must first be
            configured with a byte frequency table before the tree can be used for
            encoding and decoding <see cref="M:GT.GMC.HuffmanEncodingTree.GenerateFromFrequencyTable(System.UInt32[])"/>.
            </summary>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.#ctor">
            <summary>
            Create a new, uninitialized huffman encoding tree.  Callers must explicitly
            provide a frequency table before performing any encoding / decoding.
            </summary>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.#ctor(System.UInt32[])">
            <summary>
            Create a new huffman encoding tree initialized with the provided
            frequency table.  The resulting encoding tree is ready for encoding/decoding.
            </summary>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.EncodeArray(System.Byte[])">
            <summary>
            Encode the provided bytes using this tree.  We refer to the result as
            a "huffed byte array".
            </summary>
            <param name="input">the byte array to be encoded using this tree</param>
            <returns>the huffed byte array</returns>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.EncodeArrayToBitArray(System.Byte[])">
            <summary>
            Turns a byte array into a huffed BitArray
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.DecodeBitArray(GT.Utils.BitTuple)">
            <summary>
            Decode a Huffed BitArray into a byte array
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.DecodeArray(System.Byte[])">
            Decodes a huffman encoded byte array into a (hopefully larger) byte array.
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.GenerateFromFrequencyTable(System.UInt32[])">
            builds the huffman tree frequencies should be 256 values long 
        </member>
        <member name="M:GT.GMC.HuffmanEncodingTree.ConvertBytes(System.Byte[])">
            turns a byteset into a bittuple 
        </member>
        <member name="T:GT.Utils.ByteUtils">
            <summary>
            Set of useful functions for byte arrays including:
            <ul>
            <li> dumping human-readable representations; </li>
            <li> finding differences between byte-arrays; </li>
            <li> reading and writing to streams; </li>
            <li> reading and writing compact representations of
                 integers and dictionaries. </li>
            </ul>
            </summary>
        </member>
        <member name="M:GT.Utils.ByteUtils.EncodeLength(System.UInt32,System.IO.Stream)">
            <summary>
            Encode a length on the stream in such a way to minimize the number of bytes required.
            Top two bits are used to record the number of bytes necessary for encoding the length.
            Assumes the length is &lt; 2^30 elements.  Lengths &lt; 64 elelements will fit in a single byte.
            </summary>
            <param name="length">the length to be encoded</param>
            <param name="output">where the encoded length should be placed.</param>
        </member>
        <member name="M:GT.Utils.ByteUtils.EncodeLength(System.UInt32)">
            <summary>
            Encode a length as a byte array.
            Top two bits are used to record the number of bytes necessary for encoding the length.
            Assumes the length is &lt; 2^30 elements.  Lengths &lt; 64 elelements will fit in a single byte.
            </summary>
            <param name="length">the length to be encoded</param>
        </member>
        <member name="M:GT.Utils.ByteUtils.DecodeLength(System.IO.Stream)">
            <summary>
            Decode a length from the stream as encoded by EncodeLength() above.
            Top two bits are used to record the number of bytes necessary for encoding the length.
            </summary>
            <param name="input">stream containing the encoded length</param>
            <returns>the decoded length</returns>
        </member>
        <member name="M:GT.Utils.ByteUtils.DecodeLength(System.Byte[],System.Int32@)">
            <summary>
            Decode a length from the stream as encoded by EncodeLength() above.
            Top two bits are used to record the number of bytes necessary for encoding the length.
            </summary>
            <param name="bytes">byte content containing the encoded length</param>
            <param name="index">in: the index in which to decode the byte length, out: set to
            the index of the first byte following the encoded length</param>
            <returns>the decoded length</returns>
        </member>
        <member name="M:GT.Utils.ByteUtils.DecodeLength(System.Byte[])">
            <summary>
            Decode a length from the stream as encoded by EncodeLength() above.
            Top two bits are used to record the number of bytes necessary for encoding the length.
            </summary>
            <param name="bytes">byte content containing the encoded length</param>
            <returns>the decoded length</returns>
        </member>
        <member name="M:GT.Utils.ByteUtils.EncodedDictionaryByteCount(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Figure out how many bytes would be necessary to encode the provided dictionary
            using our bencoding-like format.
            </summary>
        </member>
        <member name="M:GT.Utils.ByteUtils.EncodeDictionary(System.Collections.Generic.IDictionary{System.String,System.String},System.IO.Stream)">
            <summary>
            Encode a strings dictionary onto a stream as using our bencoding-like format.
            </summary>
            <param name="dict">the dictionary to encode</param>
            <param name="output">the stream from which to decode</param>
            <returns>the decoded dictionary</returns>
        </member>
        <member name="M:GT.Utils.ByteUtils.DecodeDictionary(System.IO.Stream)">
            <summary>
            Decode a strings dictionary from a stream encoded in our bencoding-like format.
            </summary>
            <param name="input">the stream from which to decode</param>
            <returns>the decoded dictionary</returns>
        </member>
        <member name="T:GT.GMC.SuffixTrie">
            <summary>
            A suffix trie represents the suffixes of a given string (say <c>s</c>) in 
            a way allowing fast determination whether another string <c>w</c> is a
            substring of <c>s</c> in O(|<c>w</c>|).
            
            Definition (from Gusfield, below): A suffix tree <c>T</c> for an <c>m</c> character 
            string <c>s</c> is a rooted tree with exactly <c>m</c> leaves numbers 1 through <c>m</c>.  
            Each internal node, other than the root, has at least two children and each edge is 
            labelled with a nonempty substring of <c>s</c>.  No two edges out of a node can have
            edge-labels beginning with the same character.  The key feature of the suffix tree
            is that for any leaf <c>i</c>, the concatenation of the edge-labels on the path
            from the root to leaf <c>i</c> spells out the suffix of <c>s</c> that starts at
            position <c>i</c>.  That is, it spels out <c>s[i..m]</c>
            
            Further details: D Gusfield (1997). Algorithms on Strings, Trees and Sequences. 
            CUP. ISBN 0-521-58519-8 (QA76.9.A43G87)
            </summary>
        </member>
        <member name="M:GT.GMC.SuffixTrie.#ctor">
            <summary>
            Creates a new suffix trie.
            </summary>
        </member>
        <member name="M:GT.GMC.SuffixTrie.Add(System.Byte[])">
            <summary>
            Adds a string to the dictionary that the templates uses.
            </summary>
            <param name="key">the string to be added</param>
        </member>
        <member name="M:GT.GMC.SuffixTrie.GetCode(System.Byte[],System.Int32@,System.Int32@)">
            <summary>
            Search for and return an encoding for the maximal byte sequence found in
            <see cref="!:key"/> starting at position <see cref="!:startIndex"/>.  At the 
            conclusion of this method, the encoding for the maximal byte sequence will 
            be returned. <see cref="!:escapedIndex"/> will point to the start of bytes
            that do not have an encoding.  <see cref="!:startIndex"/> will have been 
            advanced to the next character after the maximal seqence and after any
            bytes needing to be escaped; if <see cref="!:startIndex"/> == <see cref="!:escapedIndex"/>
            then no bytes needed escaping.
            </summary>
            <param name="key">the bytes</param>
            <param name="startIndex">starting point in <see cref="!:key"/> for encoding</param>
            <param name="escapedIndex">pointer to sequence of bytes that cannot be encoded</param>
            <returns>the encoding</returns>
        </member>
        <member name="M:GT.GMC.SuffixTrie.GenerateEncodingTable">
            <summary>
            Returns a list used for decoding keys in the tables
            </summary>
            <returns></returns>
        </member>
        <member name="T:GT.GMC.TrieNode">
            <summary>
            The result of looking up a key in a suffix trie representing a particular message.
            Code is the index of where the key begins in the represented message.
            If the key is not a substring of the represented message, then the unmatched suffix of 
            the key that was not matched will be placed in remainder.
            </summary>
        </member>
        <member name="M:GT.GMC.TrieNode.Update(System.Byte[],System.Int32,System.UInt32@)">
            <summary>
            Recursively updates the trie, given the current size (not counting the root) 
            of the trie.  To avoid generating unnecessary garbage, we pass a start index
            into key.
            </summary>
            <param name="key">the key to lookup/update, relative to <see cref="!:startIndex"/></param>
            <param name="startIndex">start location into <see cref="!:key"/></param>
            <param name="nextCode">the next code to be assigned</param>
        </member>
        <member name="M:GT.GMC.TrieNode.GetCode(System.Byte[])">
            <summary>Recursively search for a code.</summary>
        </member>
        <member name="M:GT.GMC.TrieNode.GetCode(System.Byte[],System.Int32@)">
            <summary>
            Recursively search for a code. After GetCode(), startIndex will 
            point to the *next* character to consider. So 
            message[startIndex .. startIndex'-1] will be represented by the return code.
            </summary>
        </member>
        <member name="M:GT.GMC.TrieNode.BuildTable(System.Collections.Generic.IList{System.Byte[]})">
            <summary>
            Traverse entire tree, building a table to map code indices to key values
            </summary>
            <param name="table"></param>
        </member>
        <member name="F:GT.GMC.HuffmanCompressor.changed">
            <summary>
            Has the byte frequency changed since the Huffman encoding was last updated?
            </summary>
        </member>
        <member name="F:GT.GMC.HuffmanCompressor.useHuff">
            <summary>
            Should huffman encoding be used?  (Distinct from: can huffman encoding be used?
            determined by whether a huffman-encoding tree has been generated.)
            </summary>
        </member>
        <member name="F:GT.GMC.HuffmanCompressor.byteUsage">
            <summary>
            The per-byte usage.
            </summary>
        </member>
        <member name="F:GT.GMC.HuffmanCompressor.het">
            <summary>
            The generated huffman-encoding tree
            </summary>
        </member>
        <member name="F:GT.GMC.HuffmanCompressor.huffedTrees">
            <summary>
            Statistics: record how many trees have been generated
            </summary>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.HuffmanActive">
            <summary>
            Return true if huffman encoding is active and *available* (e.g., a tree was made).
            </summary>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.Encode(System.Byte[])">
            <summary>
            Turn a sequence of shortcuts for this compressor into a huff-encoding.
            Return null if we're not currently active.
            </summary>
            <param name="bytes">The bytes to be Huffman encoded</param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.Decode(System.Byte[])">
            <summary>
            Turn huffed values back into a sequence of shortcuts.
            </summary>
            <param name="huffedBytes">the huffman-encoded bytes</param>
            <returns>expanded set of bytes</returns>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.SetFrequencies(System.UInt32[])">
            <summary>
            Update the usage values 
            </summary>
            <param name="newusages"></param>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.UpdateHuffmanEncoding">
            <summary>
            Build/update a huffman encoding tree (if necessary) for this set of shortcuts 
            given the current set of byte usages.
            </summary>
        </member>
        <member name="M:GT.GMC.HuffmanCompressor.NoteUsage(System.Byte)">
            <summary>
            Note usage of a particular byte value; note that the Huffman tree will require
            being updated
            </summary>
            <param name="value">the byte usd</param>
        </member>
        <member name="P:GT.GMC.HuffmanCompressor.HuffmanEncoding">
            <summary>
            Returns true if data should be huffman-encoded, false otherwise.
            </summary>
        </member>
        <member name="T:GT.Utils.Bag`1">
            <summary>
            A bag, similar to a set but where a count is maintained for each item
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:GT.Utils.SingleItem`1">
            <summary>
            A compact list intended for lists containing at most a single item.
            </summary>
            <typeparam name="T">the type of the objects making up this collection's contents</typeparam>
        </member>
        <member name="T:GT.Utils.SharedQueue`1">
            <summary>
            A thread-safe shared queue.  Inpired by various sources on the
            internet.
            </summary>
            <typeparam name="T">the type of the objects making up this collection's contents</typeparam>
        </member>
        <member name="M:GT.Utils.SharedQueue`1.TryDequeue(`0@)">
            <summary>
            Try to dequeue an object.
            </summary>
            <param name="value">the dequeued result, or the default of <typeparamref name="T"/>
            if the timeout expires.</param>
            <returns>true if a value was dequeued, or false if there was nothing available</returns>
        </member>
        <member name="P:GT.Utils.SharedQueue`1.Count">
            <summary>
            Return the number of objects available in this queue.
            </summary>
        </member>
        <member name="T:GT.Utils.SequentialSet`1">
            <summary>
            A simple class for maintaining an ordered set of items as ordered
            by time of first entry.  New items that are already present are ignored.
            New items that are not present are added to the end of the set.
            </summary>
            <typeparam name="T">the type of the objects making up this collection's contents</typeparam>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
             Create a sequential set with the provided items in their presented order.
            </summary>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.#ctor">
            <summary>
             Create an empty sequential set
            </summary>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.Add(`0)">
            <summary>
            Add the provided item to the set.
            </summary>
            <param name="item">the item to be added</param>
            <returns>true if the item was newly added, or false if the item
               was already part of the set</returns>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.Remove(`0)">
            <summary>
             Remove the provided item, if present.
            </summary>
            <param name="item">the item to be removed</param>
            <returns>true if present, false otherwise</returns>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.Contains(`0)">
            <summary>
            Return true if the provided item is part of this set.
            </summary>
            <param name="item">the item to be checked</param>
            <returns>true if the provided item is part of the set, false otherwise</returns>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.GetEnumerator">
             <summary>
            Return an enumerator for the items that maintains the item order.
             </summary>
             <returns>an enumerator</returns>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.System#Collections#IEnumerable#GetEnumerator">
             <summary>
            Return an enumerator for the items that maintains the item order.
             </summary>
             <returns>an enumerator</returns>
        </member>
        <member name="M:GT.Utils.SequentialSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the items in the provided enumerable.
            </summary>
            <param name="collection">the items to be added</param>
        </member>
        <member name="P:GT.Utils.SequentialSet`1.Item(System.Int32)">
            <summary>
            Returns the element at the provided index.
            </summary>
            <param name="index">the element position</param>
            <returns>the element at the provided index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a 
            valid index in the set</exception>
        </member>
        <member name="T:GT.Utils.WeakKeyDictionary`2">
            <summary>
            A dictionary whose keys are stored as a weak reference.  These
            dictionaries do not implement the full <see cref="T:System.Collections.Generic.IDictionary`2"/>
            protocol as some methods will be O(n).
            </summary>
            <typeparam name="TKey">the type of the objects making up this collection's keys</typeparam>
            <typeparam name="TValue">the type of the objects making up this collection's values</typeparam>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.Clear">
            <summary>
            Discard all ke-value pairs in this dictionary.
            </summary>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.Flush">
            <summary>
            Check the dictionary, discarding all key-value pairs where
            the key has been collected.
            </summary>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.ContainsKey(`0)">
            <summary>
            Check to see if <see cref="!:key"/> is a key in this dictionary.
            </summary>
            <param name="key">the value to check</param>
            <returns>true if <see cref="!:key"/> is a key</returns>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.Add(`0,`1)">
            <summary>
            Add the provided key-value pair.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <exception cref="T:System.ArgumentNullException">thrown if <see cref="!:key"/> 
                is null.</exception>
            <exception cref="T:System.ArgumentException">thrown if anelement with the 
                same key already exists in the dictionary.</exception>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.Remove(`0)">
            <summary>
            Remove the value associated with the key, if present.
            </summary>
            <param name="key">the key</param>
            <returns>true if the value was removed, false if no associated value was found</returns>
        </member>
        <member name="M:GT.Utils.WeakKeyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Try to fetch the value associated with the provided key.
            </summary>
            <param name="key">the key</param>
            <param name="value">the value, if found</param>
            <returns>true if the value was found, false if none found</returns>
        </member>
        <member name="P:GT.Utils.WeakKeyDictionary`2.Count">
            <summary>
            Return the number of key-value pairs contained in this
            dictionary.  This is an expensive operation as every
            pair must be checked to verify that the key has not
            yet been collected.
            </summary>
        </member>
        <member name="P:GT.Utils.WeakKeyDictionary`2.IsReadOnly">
            <summary>
            Is this instance read-only?
            </summary>
        </member>
        <member name="P:GT.Utils.WeakKeyDictionary`2.Item(`0)">
            <summary>
            Return or set the value associated with <see cref="!:key"/>
            </summary>
            <param name="key">the key</param>
            <returns>the value</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">if the key is not present</exception>
        </member>
        <member name="P:GT.Utils.WeakKeyDictionary`2.Keys">
            <summary>
            Returns a collection of the valid keys.
            </summary>
        </member>
        <member name="T:GT.Utils.WeakCollection`1">
            <summary>
            A set whose elements are stored as a weak reference.
            </summary>
            <typeparam name="T">the type of the objects making up this collection</typeparam>
        </member>
        <member name="P:GT.Utils.WeakCollection`1.Count">
            <summary>
            Return the number of still-alive target objects in the collection
            </summary>
        </member>
        <member name="T:GT.Utils.WeakReference`1">
            <summary>
            A simple type-safe wrapper of <see cref="T:System.WeakReference"/>
            </summary>
            <typeparam name="T">the type of the target object</typeparam>
        </member>
        <member name="F:GT.Utils.WeakReference`1.hash">
            <summary>
            The hash value for the target (stored in case the target disappears)
            </summary>
        </member>
        <member name="M:GT.Utils.WeakReference`1.#ctor(`0)">
            <summary>
            Create a new type-safe weak reference object
            </summary>
            <param name="target">the referenced target object</param>
        </member>
        <member name="P:GT.Utils.WeakReference`1.Value">
            <summary>
            Get/set the value of the weak reference.
            </summary>
        </member>
        <member name="T:GT.Utils.DelayQueue`1">
            <summary>
            A simple delay queue similar in spirit to the java.util.concurrent.DelayQueue class.  
            Elements are inserted with some delay count using
            <see cref="M:GT.Utils.DelayQueue`1.Enqueue(`0,System.UInt32)"/>.  The delay counts are represented as the relative number 
            of unitless ticks (e.g., could correspond to milliseconds).  Elements can only be
            dequeued when their delay has expired.  Time passing is indicated by periodically
            calling <see cref="M:GT.Utils.DelayQueue`1.Dequeue(System.UInt32,System.Action{`0})"/> with the number of ticks that have elapsed since
            the last call; any elements whose delay has expired are then dequeued and
            reported.
            </summary>
            <typeparam name="T">the type of elements</typeparam>
        </member>
        <member name="F:GT.Utils.DelayQueue`1.nodePool">
            <summary>
            We use a managed pool to minimize memory overhead
            </summary>
        </member>
        <member name="F:GT.Utils.DelayQueue`1.first">
            <summary>
            the first element in the delay queue: this is the node that
            will expire earliest.
            </summary>
        </member>
        <member name="M:GT.Utils.DelayQueue`1.#ctor">
            <summary>
            Create a new delay queue instance
            </summary>
        </member>
        <member name="M:GT.Utils.DelayQueue`1.Enqueue(`0,System.UInt32)">
            <summary>
            Enqueue the given element for at least <see cref="!:delay"/> ticks.
            </summary>
            <param name="element">the element to be enqueued</param>
            <param name="delay">the number of ticks the element must be kept for</param>
        </member>
        <member name="M:GT.Utils.DelayQueue`1.Dequeue(System.UInt32,System.Action{`0})">
            <summary>
            Notify that <see cref="!:elapsed"/> ticks have elapsed.
            Dequeue any items whose delays have expired, triggering
            the <see cref="!:dequeued"/> delegate.
            </summary>
            <param name="elapsed">the number of ticks elapsed since the last call</param>
            <param name="dequeued">a delegate triggered with all elements whose delay 
            has expired</param>
            <returns>true if some elements expired, false otherwise</returns>
        </member>
        <member name="P:GT.Utils.DelayQueue`1.Count">
            <summary>
            The number of elements in this queue
            </summary>
        </member>
        <member name="P:GT.Utils.DelayQueue`1.MaximumDelay">
            <summary>
            The maximum delay for any element in this queue.
            </summary>
        </member>
        <member name="T:GT.Utils.DelayQueue`1.DelayNode">
            <summary>
            DelayNode captures the necessary information in the delay
            list.  The delay list is sorted by time remaining; each node
            contains a delta of the number of additional ticks relative to
            its parent.
            </summary>
        </member>
        <member name="M:GT.Utils.DelayQueue`1.DelayNode.Clear">
            <summary>
            Clear the contents of this node
            </summary>
        </member>
        <member name="T:GT.Net.RemoteTuple`1">
            <summary>Represents a 1-tuple.</summary>
            <typeparam name="T_X">The type of the tuple parameter X.</typeparam>
        </member>
        <member name="F:GT.Net.RemoteTuple`1.x">
            <summary>The value of this tuple.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`1.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`1.#ctor(`0)">
            <summary>Constructor.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`1.X">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="T:GT.Net.RemoteTuple`2">
            <summary>Represents a 2-tuple.</summary>
            <typeparam name="T_X">The type of the tuple parameter X.</typeparam>
            <typeparam name="T_Y">The type of the tuple parameter Y.</typeparam>
        </member>
        <member name="F:GT.Net.RemoteTuple`2.x">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="F:GT.Net.RemoteTuple`2.y">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`2.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`2.#ctor(`0,`1)">
            <summary>Constructor.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`2.X">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`2.Y">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="T:GT.Net.RemoteTuple`3">
            <summary>Represents a 3-tuple.</summary>
            <typeparam name="T_X">The type of the tuple parameter X.</typeparam>
            <typeparam name="T_Y">The type of the tuple parameter Y.</typeparam>
            <typeparam name="T_Z">The type of the tuple parameter Z.</typeparam>
        </member>
        <member name="F:GT.Net.RemoteTuple`3.x">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="F:GT.Net.RemoteTuple`3.y">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="F:GT.Net.RemoteTuple`3.z">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`3.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:GT.Net.RemoteTuple`3.#ctor(`0,`1,`2)">
            <summary>Constructor.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`3.X">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`3.Y">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="P:GT.Net.RemoteTuple`3.Z">
            <summary>A value of this tuple.</summary>
        </member>
        <member name="T:GT.Net.TupleMessage">
            <summary>
            A message containing a revised tuple from a particular client.
            </summary>
        </member>
        <member name="M:GT.Net.TupleMessage.#ctor(System.Byte,System.Int32,System.IConvertible)">
            <summary>
            Encode a 1D tuple
            </summary>
            <param name="channelId">the channel</param>
            <param name="clientId">the client sending the tuple</param>
            <param name="x">the tuple value</param>
        </member>
        <member name="M:GT.Net.TupleMessage.#ctor(System.Byte,System.Int32,System.IConvertible,System.IConvertible)">
            <summary>
            Encode a 2D tuple
            </summary>
            <param name="channelId">the channel</param>
            <param name="clientId">the client sending the tuple</param>
            <param name="x">the first tuple component</param>
            <param name="y">the second tuple component</param>
        </member>
        <member name="M:GT.Net.TupleMessage.#ctor(System.Byte,System.Int32,System.IConvertible,System.IConvertible,System.IConvertible)">
            <summary>
            Encode a 3D tuple
            </summary>
            <param name="channelId">the channel</param>
            <param name="clientId">the client sending the tuple</param>
            <param name="x">the first tuple component</param>
            <param name="y">the second tuple component</param>
            <param name="z">the third tuple component</param>
        </member>
        <member name="P:GT.Net.TupleMessage.ClientId">
            <summary>
            Return the id of the client that sent this tuple
            </summary>
        </member>
        <member name="P:GT.Net.TupleMessage.Dimension">
            <summary>
            Return the number of components in this tuple
            </summary>
        </member>
        <member name="P:GT.Net.TupleMessage.X">
            <summary>
            Return the tuple's X component
            </summary>
        </member>
        <member name="P:GT.Net.TupleMessage.Y">
            <summary>
            Return the tuple's Y component
            </summary>
        </member>
        <member name="P:GT.Net.TupleMessage.Z">
            <summary>
            Return the tuple's Z component
            </summary>
        </member>
        <member name="T:GT.Severity">
            <summary>
            Describes the impact of an error or exception.
            </summary>
        </member>
        <member name="F:GT.Severity.Fatal">
            <summary>
            Fatal: an error has occurred such that GT cannot continue in its operation.
            </summary>
        </member>
        <member name="F:GT.Severity.Error">
            <summary>
            Error: an error has occurred; the application will likely be able to continue, but GT functionality 
            may be significantly limited.
            </summary>
        </member>
        <member name="F:GT.Severity.Warning">
            <summary>
            Warning: an error has occurred such that GT is able to continue, but the application's 
            functionality may be compromised.
            </summary>
        </member>
        <member name="F:GT.Severity.Information">
            <summary>
            Information: a problem has occurred but has been dealt with; the error is being 
            reported purely for informational purposes.
            </summary>
        </member>
        <member name="T:GT.ContractViolation">
            <summary>
            Captures situations where there is a violation of a documented contraint or
            contract.
            </summary>
        </member>
        <member name="M:GT.ContractViolation.#ctor(GT.Severity,System.String)">
            <summary>
            Create an instance documenting a contract violation
            </summary>
            <param name="sev">the associate severity of the violation</param>
            <param name="message">text describing the violation</param>
        </member>
        <member name="M:GT.ContractViolation.Assert(System.Boolean,System.String)">
            <summary>
            If <c>condition</c> is false, create and throw an instance of this exception type.
            This method serves as syntactic sugar to save coding space.
            </summary>
            <param name="condition">the result of a test</param>
            <param name="text">descriptive text if the test fails</param>
        </member>
        <member name="M:GT.ContractViolation.Assert(System.Boolean,System.String[])">
            <summary>
            If <c>condition</c> is false, create and throw an instance of this exception type.
            This method serves as syntactic sugar to save coding space.  This method
            invokes <see cref="M:System.String.Format(System.String,System.Object[])"/> on the text argument.
            </summary>
            <param name="condition">the result of a test</param>
            <param name="text">descriptive text if the test fails</param>
        </member>
        <member name="T:GT.InvalidStateException">
            <summary>
            Denotes an problem.
            </summary>
        </member>
        <member name="M:GT.InvalidStateException.#ctor(System.String,System.Object)">
            <summary>
            Initializes a new instance of the System.Exception class with a specified error message
            and a reference to some object that is the cause of this exception.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="source">The object that is the cause of the current exception.</param>
        </member>
        <member name="M:GT.InvalidStateException.Assert(System.Boolean,System.String,System.Object)">
            <summary>
            If <c>condition</c> is false, create and throw an instance of this exception type.
            This method serves as syntactic sugar to save coding space.
            </summary>
            <param name="condition">the result of a test</param>
            <param name="text">descriptive text if the test fails</param>
            <param name="source">the object whose state is invalid</param>
        </member>
        <member name="F:GT.Net.TcpTransport.DefaultMaximumMessageSize">
            <summary>
            512 is the historical value supported by GT.
            </summary>
        </member>
        <member name="M:GT.Net.TcpTransport.SendPacket(GT.Net.TransportPacket)">
            <summary>Send a packet to server.</summary>
            <param name="packet">The packet to send.</param>
        </member>
        <member name="T:GT.Net.Utils.PingBasedDisconnector">
            <summary>
            A simple utility class that drops transports that do not respond to
            GT's periodic heart-beat within a certain time.  This utility uses
            GT's events to automatically become aware of new connexions and
            transports.  The utility is installed onto a <see cref="!:GT.Net.Client"/> 
            or <see cref="!:GT.Net.Server"/> through <see cref="M:GT.Net.Utils.PingBasedDisconnector.Install(GT.Net.Communicator,System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:GT.Net.Utils.PingBasedDisconnector.Install(GT.Net.Communicator,System.TimeSpan)">
            <summary>
            Install a disconnector on the provided communicator.
            </summary>
            <param name="c"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:GT.Net.Utils.PingBasedDisconnector.#ctor(GT.Net.Communicator,System.TimeSpan)">
            <summary>
            Create a new disconnector instance; this instance must still be started.
            </summary>
            <param name="c">the communicator to be installed against</param>
            <param name="timeout">the inactivity timeout period</param>
        </member>
        <member name="M:GT.Net.Utils.PingBasedDisconnector.Start">
            <summary>
            Start the disconnector.
            </summary>
        </member>
        <member name="M:GT.Net.Utils.PingBasedDisconnector.Stop">
            <summary>
            Stop the disconnector.
            </summary>
        </member>
        <member name="E:GT.Net.Utils.PingBasedDisconnector.ErrorEvent">
            <summary>
            Provide notification of any errors that may occur.
            </summary>
        </member>
        <member name="T:GT.Net.Utils.NetworkEmulatorTransport">
            <summary>
            A simple class for simulating certain network transmission characteristics
            onto a transport.  This class was inspired by the Linux WanEm network emulator.
            The implementation of this transport does induce some minimum latency on every call.
            Please note that this interface is likely to change in subsequent releases.  
            Packet loss is only done for those transports that either unreliable or not ordered.
            Packet reordering is only done for transports that are unordered.
            
            <para>
            The packet delay can be set either as a fixed quantity through the <see cref="P:GT.Net.Utils.NetworkEmulatorTransport.PacketFixedDelay"/> 
            property, or as calculated from a delay provider.  The fixed quantity is used
            like:
            </para>
            <code>
                // introduce fixed packet delay
                transport.PacketDelay = TimeSpan.FromMilliseconds(30);
            </code>
            <para>
            The delay provider can be used to sample delay from a probability distribution, 
            such as a Gaussian or Poisson.
            For example:
            </para>
            <code>
                GaussianRandomNumberGenerator grng = new GaussianRandomNumberGenerator(200, 30);
                transport.DelayProvider = () =&gt; TimeSpan.FromMilliseconds(grng.NextDouble());
            </code>
            An alternative might be to model a Poisson process by sampling from a negative 
            exponential probability distribution to simulate interarrival times:
            <code>
                Random r = new Random();
                transport.DelayProvider = 
                    () =&gt; TimeSpan.FromMilliseconds(Math.Min(-Math.Log(random.NextDouble()), 5.0) * 1000);
            </code>
            This class does the right thing for ordered transports.
            </summary>
        </member>
        <member name="T:GT.Net.WrappedTransport">
            <summary>
            A basic transport wrapper.
            </summary>
        </member>
        <member name="M:GT.Net.WrappedTransport.#ctor(GT.Net.ITransport)">
            <summary>
            Wrap the provided transport.
            </summary>
            <param name="wrapped">the transport to be wrapped</param>
        </member>
        <member name="P:GT.Net.WrappedTransport.Wrapped">
            <summary>
            Return the wrapper transport instance
            </summary>
        </member>
        <member name="M:GT.Net.Utils.NetworkEmulatorTransport.#ctor(GT.Net.ITransport)">
            <summary>
            Create a new instance.  See the class comments for details.
            </summary>
            <param name="wrapped">the transport to be wrapped</param>
        </member>
        <member name="F:GT.Net.Utils.NetworkEmulatorTransport.pLastDropped">
            <summary>
            The probability that the last packet was dropped, kept for
            statistical correlation of packet loss.
            </summary>
            <seealso cref="P:GT.Net.Utils.NetworkEmulatorTransport.PacketLossCorrelation"/>
        </member>
        <member name="E:GT.Net.Utils.NetworkEmulatorTransport.PacketDisposition">
            <summary>
            Provide notification as to the disposition taken for each packet sent.
            </summary>
        </member>
        <member name="P:GT.Net.Utils.NetworkEmulatorTransport.PacketLoss">
            <summary>
            The probability that a packet is dropped.
            If <see cref="P:GT.Net.Utils.NetworkEmulatorTransport.PacketLossCorrelation"/> is non-zero, then the probability
            of a packet being dropped will be statistically correlated with
            the probability that the previous packet was dropped.
            Applies both to packets sent and received.
            </summary>
        </member>
        <member name="P:GT.Net.Utils.NetworkEmulatorTransport.PacketLossCorrelation">
            <summary>
            Make the probability of a packet being dropped be statistically
            correlated with the probability that the previous packet was dropped.
            Applies both to packets sent and received.
            </summary>
        </member>
        <member name="P:GT.Net.Utils.NetworkEmulatorTransport.PacketReordering">
            <summary>
            The probability of a packet being reordered.
            Applies both to packets sent and received.
            </summary>
        </member>
        <member name="P:GT.Net.Utils.NetworkEmulatorTransport.PacketFixedDelay">
            <summary>
            Get/set the fixed delay to be imposed on every packet.
            If there is a delay provider, then return a value &lt;= 0.
            </summary>
            <seealso cref="P:GT.Net.Utils.NetworkEmulatorTransport.DelayProvider"/>
        </member>
        <member name="P:GT.Net.Utils.NetworkEmulatorTransport.DelayProvider">
            <summary>
            Get/set a delegate for sampling a delay to be applied to each packet.
            Such a delegate is useful for sampling from a random process.
            If null, then we use the <see cref="P:GT.Net.Utils.NetworkEmulatorTransport.PacketFixedDelay"/>.
            </summary>
            <seealso cref="P:GT.Net.Utils.NetworkEmulatorTransport.PacketFixedDelay"/>
        </member>
        <member name="T:GT.Net.Utils.NetworkEmulatorTransport.PacketMode">
            <summary>
            Encode the transport mode of a packet, whether it is being sent or received.
            </summary>
        </member>
        <member name="T:GT.Net.Utils.NetworkEmulatorTransport.PacketEffect">
            <summary>
            Encode the transform to be effected on the packet.
            </summary>
        </member>
        <member name="T:GT.Net.IPacketScheduler">
            <summary>
            Packet schedulers are provided the opportunity to come up with alternative
            packet scheduling schemes, such as round-robin or weighted fair queueing.
            Packet schedulers are created with two delegates for (1) obtaining the
            list of active transports, and (2) to marshal a message for a particular
            transport.
            </summary>
            <remarks>
            Packet schedulers are not thread safe.
            </remarks>
        </member>
        <member name="M:GT.Net.IPacketScheduler.Schedule(GT.Net.Message,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>
            Schedule the packets forming the provided message.  When the message
            has been sent, be sure to dispose of the marshalled result.
            </summary>
            <param name="m">the message being sent</param>
            <param name="mdr">the message's delivery requirements (overrides 
                <see cref="!:cdr"/> if not null)</param>
            <param name="cdr">the message's channel's delivery requirements</param>
        </member>
        <member name="M:GT.Net.IPacketScheduler.Update">
            <summary>
            
            </summary>
        </member>
        <member name="M:GT.Net.IPacketScheduler.Flush">
            <summary>
            Flush all remaining messages.
            </summary>
        </member>
        <member name="M:GT.Net.IPacketScheduler.FlushChannelMessages(System.Byte)">
            <summary>
            Flush all remaining messages for the specific channelId.
            </summary>
        </member>
        <member name="M:GT.Net.IPacketScheduler.Reset">
            <summary>
            Reset the instance; throw away all data.
            </summary>
        </member>
        <member name="T:GT.Net.AbstractPacketScheduler">
            <summary>
            Provides useful base for other schedulers.
            </summary>
        </member>
        <member name="T:GT.Net.ImmediatePacketScheduler">
            <summary>
            A FIFO scheduler where each message is shipped out as it is received
            </summary>
        </member>
        <member name="T:GT.Net.RoundRobinPacketScheduler">
            <summary>
            A round-robin scheduler: we alternate between each channel.
            We rotate on a per-channel basis to ensure a channel sending many 
            packets (e.g., a video stream) won't starve other channels.
            </summary>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.nextChannelIndex">
            <summary>
            These values hold metadata for the round-robin.  
            </summary>
            <remarks>
            nextChannelIndex is an index
            into channels, indicating the channelId from which to take the next message.  
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.channels">
            <remarks>
            channels is a list of channel ids in first-come-first-served order;
            note that SystemMessages encode the system request as the channel id,
            and so will be inserted as if from a particular channel.  Finally,
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.channelIndices">
            <remarks>
            channelIndices is a reversee mapping of channel id to index within
            channels; it acts as a fast-lookup.
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.channelSendingStates">
            <summary>
            These dictionaries record the current sending state during the
            execution of Schedule() and Flush*().  They should otherwise be empty.
            </summary>
            <remarks>
            records the current message, its marshalled form, and the transport
            selected as per its MDR/CDR.
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.packetsInProgress">
            <remarks>
            the accumulated packet for sending on a transport
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.messagesInProgress">
            <remarks>
            Records messages that span multiple packets
            </remarks>
        </member>
        <member name="F:GT.Net.RoundRobinPacketScheduler.sentMessages">
            <remarks>
            Records messages where all packets are in the process of being sent
            </remarks>
        </member>
        <member name="M:GT.Net.RoundRobinPacketScheduler.Aggregate(GT.Net.Message,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Adds the message to a list, waiting to be sent out.</summary>
            <param name="newMsg">The message to be aggregated</param>
            <param name="mdr">How it should be sent out (potentially null)</param>
            <param name="cdr">General delivery instructions for this message's channel.</param>
        </member>
        <member name="M:GT.Net.RoundRobinPacketScheduler.ProcessNextPacket(System.Byte,GT.Net.CannotSendMessagesError)">
            <summary>
            Process the next packet to be sent on <see cref="!:channelId"/>.  Return true
            if there was a packet to be processed on the channel, or false otherwise.
            </summary>
            <param name="channelId">the channel to process</param>
            <param name="csme">accumulated errors/exceptions</param>
            <returns>true if a packet was processed on the channel, or false if there are no packets
            to process or some error/exception arose</returns>
        </member>
        <member name="M:GT.Net.RoundRobinPacketScheduler.FindNextPacket(System.Byte,GT.Net.CannotSendMessagesError,GT.Net.ChannelSendingState@)">
            <summary>
            Find the next packet to be processed; return true if there are packets to 
            process on channelId.  The channel sending state is returned in <see cref="!:cs"/>.
            </summary>
            <param name="channelId"></param>
            <param name="csme"></param>
            <param name="cs"></param>
            <returns></returns>
        </member>
        <member name="T:GT.Utils.GetOpt">
            <summary>
            A simple command-line parser equivalent to the C getopt(3).
            This parser supports the use of stacked options (e.g., '-sxm'
            is equivalent to '-s -x -m'); it supports the use of '--'
            to indicate the end of options; and finally it detects a
            missing argument.  Typical use is as follows:
            <code>
            GetOpt getopt = new GetOpt(args, "abc:");
            Option opt;
            while((opt = getopt.NextOption()) != null) {
            }
            args = getopt.RemainingArguments();
            </code>
            </summary>
        </member>
        <member name="M:GT.Utils.GetOpt.NextOption">
            <summary>
            Return the next option.  Return null if there are no more options;
            use <see cref="M:GT.Utils.GetOpt.RemainingArguments"/> to retrieve the remaining arguments.
            </summary>
            <returns>the next option, or null if there are no further options</returns>
        </member>
        <member name="T:GT.Utils.Option">
            <summary>
            Represents an option found on the command line.
            <see cref="P:GT.Utils.Option.Character"/> is the character for the option.
            <see cref="P:GT.Utils.Option.Argument"/> will be the argument, if expected.
            </summary>
        </member>
        <member name="T:GT.Utils.UnknownOptionException">
            <summary>
            An exception thrown by <see cref="M:GT.Utils.GetOpt.NextOption"/> upon
            encountering an unspecified option character.
            </summary>
        </member>
        <member name="T:GT.Utils.GetOptException">
            <summary>
            A common superclass for exceptions thrown by <see cref="T:GT.Utils.GetOpt"/> parsing.
            </summary>
        </member>
        <member name="T:GT.Utils.MissingOptionException">
            <summary>
            An exception thrown by <see cref="M:GT.Utils.GetOpt.NextOption"/> should
            an option not include a specified argument.
            </summary>
        </member>
        <member name="T:GT.Utils.SlidingWindowManager">
            <summary>
            Manage a sliding window of size <see cref="P:GT.Utils.SlidingWindowManager.WindowSize"/> within an available space
            of size <see cref="P:GT.Utils.SlidingWindowManager.Capacity"/>.  Trigger the <see cref="E:GT.Utils.SlidingWindowManager.FrameExpired"/> as the window
            moves and old frames leave the window.
            </summary>
        </member>
        <member name="M:GT.Utils.SlidingWindowManager.#ctor(System.UInt32)">
            <summary>
            Create a sliding window of size <see cref="!:windowSize"/> within a space
            defined as twice the window's size.
            </summary>
            <param name="windowSize">the window size</param>
        </member>
        <member name="M:GT.Utils.SlidingWindowManager.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Create a sliding window of size <see cref="!:windowSize"/> within a space
            of size <see cref="!:capacity"/>.  <see cref="!:capacity"/> must be less
            than <see cref="!:windowSize"/>.
            </summary>
            <param name="windowSize">the space size</param>
            <param name="capacity">the window size</param>
        </member>
        <member name="M:GT.Utils.SlidingWindowManager.IsActive(System.UInt32)">
            <summary>
            Return true if the provided frame is within the current window
            </summary>
            <param name="frame">the frame number</param>
            <returns>true if the frame is within the current window, false otherwise</returns>
        </member>
        <member name="M:GT.Utils.SlidingWindowManager.IsExpectedFrame(System.UInt32)">
            <summary>
            Check to see if this is an anticipated frame -- something we haven't
            yet seen, but is within our expected boundary.  This is as opposed to
            a frame already within our current purview or an expired frame.
            </summary>
            <param name="frame">the frame seen</param>
            <returns>true if this is a frame within our expected boundary</returns>
        </member>
        <member name="M:GT.Utils.SlidingWindowManager.Seen(System.UInt32)">
            <summary>
            Indicate that the given frame has been seen; check to see
            if the window should advance, and trigger <see cref="E:GT.Utils.SlidingWindowManager.FrameExpired"/>
            for any newly-expired frames.
            </summary>
            <param name="frame">the frame seen</param>
            <returns>true if the frame is within the (possibly advanced) window, false otherwise</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">thrown if <see cref="!:frame"/>
            is out side of the range of the window</exception>
        </member>
        <member name="E:GT.Utils.SlidingWindowManager.FrameExpired">
            <summary>
            An event triggered whenever a frame leaves the window.
            The window will have been advanced by the time
            this event is triggered.
            </summary>
        </member>
        <member name="P:GT.Utils.SlidingWindowManager.Capacity">
            <summary>
            Return the size of the space.
            </summary>
        </member>
        <member name="P:GT.Utils.SlidingWindowManager.WindowSize">
            <summary>
            Return the size of the window.
            </summary>
        </member>
        <member name="P:GT.Utils.SlidingWindowManager.Count">
            <summary>
            Return the size of the window.
            </summary>
        </member>
        <member name="T:GT.Net.TransportPacket">
            <summary>
            Represents a byte-array with appropriately marshalled content ready to send
            across a particular transport.
            The purpse of this class is to provide efficient use of byte arrays.
            Transport packets, once finished with, must be explicitly disposed of 
            using <see cref="M:GT.Net.TransportPacket.Dispose"/> to deal with cleaning up any possibly 
            shared memory.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.On(System.Byte[][])">
            <summary>
            Create a transport packet that uses <see cref="!:byteArrays"/>
            as its backing store.  This approach should be compared to
            the various constructors that copy the contents onto newly 
            allocated memory (via a pool), increasing the chance that 
            the byteArrays will be made contiguous (assuming byteArrays.Length &gt; 1); 
            contiguous memory may be advantageous for sending across 
            some transports.
            </summary>
            <param name="byteArrays">the byte arrays to use as the backing store</param>
            <returns>the packet</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.CopyOf(GT.Net.TransportPacket,System.Int32,System.Int32)">
            <summary>
            Create a new marshalled packet as a subset of another packet <see cref="!:source"/>
            Note: this method makes an independent *copy* of the appropriate 
            portion of <see cref="!:source"/>; this behaviour should be compared
            to <see cref="M:GT.Net.TransportPacket.Subset(System.Int32,System.Int32)"/> which uses <see cref="!:source"/> as a backing
            store.
            The caller is responsible for the disposal of this instance
            through <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
            <param name="source">the provided marshalled packet</param>
            <param name="offset">the start position of the subset to include</param>
            <param name="count">the number of bytes of the subset to include</param>
        </member>
        <member name="F:GT.Net.TransportPacket.list">
            <summary>
            An ordered set of byte arrays; the packet is
            formed up of these segments laid one after the other.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.length">
            <summary>
            The total number of bytes in this packet.  This should be 
            equal to the sum of the <see cref="P:System.ArraySegment`1.Count"/> for
            each segment in <see cref="F:GT.Net.TransportPacket.list"/>.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.activeStream">
            <summary>
            Try to re-use streams if possible, and also to commit any
            pending changes in a stream.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.referenceCount">
            <summary>
            TransportPackets maintain a reference count.  
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor">
            <summary>
            Create a new 0-byte transport packet.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(GT.Net.TransportPacket,System.Int32,System.Int32)">
            <summary>
            Create a new marshalled packet as a subset of another packet <see cref="!:source"/>
            Note: this method uses a *copy* of the appropriate portion of <see cref="!:source"/>.
            </summary>
            <param name="source">the provided marshalled packet</param>
            <param name="offset">the start position of the subset to include</param>
            <param name="count">the number of bytes of the subset to include</param>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(System.UInt32)">
            <summary>
            Create an instance with <see cref="!:initialSize"/> bytes.
            These bytes are uninitialized.
            </summary>
            <param name="initialSize">the initial size</param>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(System.ArraySegment{System.Byte})">
            <summary>
            Create a new transport packet from the provided byte array segment.
            </summary>
            <param name="segment"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a new transport packet from the provided byte array.
            </summary>
            <param name="bytes"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(System.IO.MemoryStream)">
            <summary>
            Create a new transport packet from the provided stream contents.
            </summary>
            <param name="ms"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.#ctor(System.Byte[][])">
            <summary>
            Add the contents of the provided byte arrays.
            </summary>
            <param name="byteArrays">the set of byte arrays</param>
        </member>
        <member name="M:GT.Net.TransportPacket.Subset(System.Int32,System.Int32)">
            <summary>
            Return a subset of this marshalled packet; this subset is 
            backed by this instance, such that any changes to the contents
            of the subset are reflected in this instance too.
            The caller is responsible for the disposal of the subset
            through <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
            <param name="subsetStart">the start position of the subset</param>
            <param name="count">the number of bytes in the subset</param>
            <returns>a new packet representing the requested subset</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.Copy">
            <summary>
            Make a copy of the contents of this packet; this copy is 
            backed by this instance, such that any changes to the contents
            of the copy are reflected in this instance too.
            The caller is responsible for the disposal of the copy
            through <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
            <returns>a copy of the contents of this packet</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.Prepend(System.ArraySegment{System.Byte})">
            <summary>
            Prepend the byte segment to this item.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.Prepend(System.Byte[])">
            <summary>
            Prepend the byte segment to this item.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.Prepend(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Prepend the byte segment to this item.
            The byte segment is now assumed to belong to this packet instance
            and should not be used elsewhere!
            </summary>
            <param name="source">the source of the bytes</param>
            <param name="offset">the starting point into the source</param>
            <param name="count">the number of bytes to copy out from the source</param>
        </member>
        <member name="M:GT.Net.TransportPacket.Append(GT.Net.TransportPacket,System.Int32,System.Int32)">
            <summary>
            Append the appropriate segments of <see cref="!:source"/> to this instance.
            </summary>
            <param name="source"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.Append(System.ArraySegment{System.Byte})">
            <summary>
            Append the contents of <see cref="!:item"/> to this item.  
            </summary>
            <param name="item">source array</param>
        </member>
        <member name="M:GT.Net.TransportPacket.Append(System.Byte[])">
            <summary>
            Append the contents of <see cref="!:source"/> to this item.  
            </summary>
            <param name="source">source array</param>
        </member>
        <member name="M:GT.Net.TransportPacket.Append(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Append the specified portion of the contents of <see cref="!:source"/> to this item.  
            </summary>
            <param name="source">source array</param>
            <param name="offset">offset into <see cref="!:source"/></param>
            <param name="count">number of bytes from <see cref="!:source"/> starting 
                at <see cref="!:offset"/></param>
        </member>
        <member name="M:GT.Net.TransportPacket.TransferFirstSegment">
            <summary>
            Transfer responsibility for our first segment to the caller.
            This means that we remove it from our consideration, but don't 
            decrement its reference count.  Used by <see cref="T:GT.Net.TransportPacket.ReadStream"/>.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.PrependSegment(System.ArraySegment{System.Byte})">
            <summary>
            Prepend the provided segment to our segment list.
            </summary>
            <param name="segment">a segment allocated through <see cref="M:GT.Net.TransportPacket.AllocateSegment(System.UInt32)"/></param>
        </member>
        <member name="M:GT.Net.TransportPacket.AppendSegment(System.ArraySegment{System.Byte})">
            <summary>
            Append the provided segment to our segment list.
            </summary>
            <param name="segment">a segment allocated through <see cref="M:GT.Net.TransportPacket.AllocateSegment(System.UInt32)"/></param>
        </member>
        <member name="M:GT.Net.TransportPacket.Clear">
            <summary>
            Clear out the contents of this packet, restoring the
            packet to the same state as a newly-created instance.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.Retain">
            <summary>
            Retain a hold on this packet beyond its normal lifetime.
            This adds to the packet's reference count.  The return value
            must be checked as it may be too late to be retained.
            </summary>
            <returns>true if the object was successfully retained</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.Dispose">
            <summary>
            Packets, once finished with, must be explicitly disposed of to
            deal with cleaning up any possibly shared memory.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.CopyTo(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy the specified portion of this packet to the provided byte array.
            </summary>
            <param name="sourceStart">the starting offset into this packet</param>
            <param name="destination">the destination byte array</param>
            <param name="destIndex">the starting offset into the destination byte array</param>
            <param name="count">the number of bytes to copy</param>
        </member>
        <member name="M:GT.Net.TransportPacket.ToArray">
            <summary>
            Piece together the contents of this byte array into a 
            single contiguous byte array.
            </summary>
            <returns>the contents of this packet</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.ToArray(System.Int32,System.Int32)">
            <summary>
            Piece together a portion of the contents of this byte array into a 
            single contiguous byte array.
            </summary>
            <returns>the contents of this packet</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.SplitAt(System.Int32)">
            <summary>
            Split this instance at the given position.  This instance
            will contain the first part, and the returned packet will
            contain the remainder.  This is more efficient than
            the equivlent using <see cref="M:GT.Net.TransportPacket.ToArray(System.Int32,System.Int32)"/> and
            <see cref="M:GT.Net.TransportPacket.RemoveBytes(System.Int32,System.Int32)"/>.
            The caller is responsible for the disposal of the new instance
            through <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
            <param name="splitPosition">the position at which this instance 
            should be split; this instance will have the contents from
            [0,...,splitPosition-1] and the new instance returned will contain
            the remaining bytes</param>
            <returns>an instance containing the remaining bytes from 
            <see cref="!:splitPosition"/> onwards</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.SplitOut(System.Int32)">
            <summary>
            Split the first <see cref="!:count"/> bytes of this instance
            into a new packet, and remove the bytes from this instance.
            This can be seen as the opposite of <see cref="M:GT.Net.TransportPacket.SplitAt(System.Int32)"/>.
            This is more efficient than the equivlent using 
            <see cref="M:GT.Net.TransportPacket.ToArray(System.Int32,System.Int32)"/> and <see cref="M:GT.Net.TransportPacket.RemoveBytes(System.Int32,System.Int32)"/>.
            The caller is responsible for the disposal of the new instance
            through <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
            <param name="count">the number of bytes that should be
            split out from this instance.  The new instance returned will 
            contain the contents from [0,...,<see cref="!:count"/> - 1] and 
            this instance will have the remaining bytes.</param>
            <returns>an instance containing the bytes from 
            [0,...,<see cref="!:count"/> - 1]</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.Replace(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Replace the bytes from [sourceStart, sourceStart+count-1] with 
            buffer[bufferStart, ..., bufferStart+count-1]
            </summary>
            <param name="sourceStart">the starting point in this packet</param>
            <param name="count">the number of bytes to be replaced</param>
            <param name="buffer">the source for the replacement bytes</param>
            <param name="bufferStart">the starting point in <see cref="!:buffer"/>
            for the replacement bytes</param>
        </member>
        <member name="M:GT.Net.TransportPacket.RemoveBytes(System.Int32,System.Int32)">
            <summary>
            Remove the bytes from [offset, ..., offset + count - 1]
            </summary>
            <param name="offset">starting point of bytes to remove</param>
            <param name="count">the number of bytes to remove from <see cref="!:offset"/></param>
            <exception cref="T:System.ArgumentOutOfRangeException">thrown if offset or count are
            invalid</exception>
        </member>
        <member name="M:GT.Net.TransportPacket.ByteAt(System.Int32)">
            <summary>
            Return the byte at the given offset.
            Note that this is not, and is not intended to be, an efficient operation.
            It's actually intended more for debugging.
            </summary>
            <param name="offset">the offset into this packet</param>
            <returns>the byte at the provided offset</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">thrown if the offset is
            out of the range of this object</exception>
        </member>
        <member name="M:GT.Net.TransportPacket.BytesAt(System.Int32,System.Int32,GT.Utils.Action{System.Byte[],System.Int32})">
            <summary>
            Invoke the provided delegate for the <see cref="!:count"/> bytes
            found at the <see cref="!:offset"/> in this packet.
            Note that this is not, and is not intended to be, a terribly
            efficient operation.
            It's actually intended more for debugging.
            </summary>
            <param name="offset">the offset into this packet</param>
            <param name="count">the number of bytes to return</param>
            <param name="block">the action block to receive the bytes.</param>
            <returns>the byte at the provided offset</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">thrown if the offset is
            out of the range of this object</exception>
        </member>
        <member name="M:GT.Net.TransportPacket.Grow(System.Int32)">
            <summary>
            Grow this packet to contain <see cref="!:newLength"/> bytes.
            Callers should not assume that any new bytes are initialized to
            some particular value.
            </summary>
            <param name="newLength"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.Consolidate">
            <summary>
            Attempt to consolidate this instance to a single segment.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.AsReadStream">
            <summary>
            Open a *destructive* stream for reading from the contents of this
            packet.  This stream is destructive as the content retrieved
            through the stream is removed from the stream.
            The stream can be flushed to commit any changes to the packet.  
            The stream is automatically flushed upon any access to the packet.
            The stream is automatically closed if a write stream is opened
            upon this instance.
            </summary>
            <seealso cref="T:GT.Net.TransportPacket.ReadStream"/>
            <returns></returns>
        </member>
        <member name="M:GT.Net.TransportPacket.AsWriteStream">
            <summary>
            Open a writeable stream on the contents of this packet.
            The stream is initially positioned at the beginning of
            the packet, thus data written will overwrite the contents
            of the stream.  
            The stream can be flushed to commit any changes to the packet.  
            The stream is automatically flushed upon any access to the packet.
            The stream is automatically closed if a read stream is opened
            upon this instance.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket._minSegmentSize">
            These methods act as a sort of malloc-like system.
            Segments may be shared between multiple packets; the segments use
            a fixed number of bytes at the beginning to record a header.
            This header records a reference count.  As segments are added
            to a packet, it should increment the ref count.  As segments
            are removed or the packet is disposed, the segments should be
            released.  When a segment has refcount == 1, then only one
            user is using the segment, and the segment may be resized with 
            impunity.  Such resizing should only be done by acquiring the
            segment array's lock.
        </member>
        <member name="F:GT.Net.TransportPacket.ReservedInitialBytes">
            <summary>
            Reserve this many bytes at the beginning of each segment to
            support prepending additional data headers in-place.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.staticLockObject">
            <summary>
            Although the memoryPools, once allocated, can be accessed in a thread-safe
            manner, there is a possibility of a race condition until they are initialized.
            This object is used to synchronize the initialization
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.segmentHeader">
            <summary>
            Each segment has 4 bytes for recording the ref count of the segment.
            The first 3 bytes should be 0xC0FFEE; this is used for detecting 
            segments not allocated through these functions and for possible
            segment overruns.  The 4th byte records the ref count.  Byte arrays
            can be reused when this goes to 0.
            </summary>
        </member>
        <member name="M:GT.Net.TransportPacket.AllocateSegment(System.UInt32)">
            <summary>
            Allocate a segment of at least <see cref="!:minimumLength"/> bytes.  This must be
            less than <see cref="P:GT.Net.TransportPacket.MaxSegmentSize"/>.  The actual byte array allocated may be
            larger than the requested length.  This segment has a ref
            count of 0 -- it must be retained such as through an
            <see cref="M:GT.Net.TransportPacket.AppendSegment(System.ArraySegment{System.Byte})"/> or explicitly though <see cref="M:GT.Net.TransportPacket.IncrementRefCount(System.ArraySegment{System.Byte})"/>.
            </summary>
            <param name="minimumLength">the minimum number of bytes required</param>
            <returns>a suitable byte segment</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">thrown when requesting an
                invalid length</exception>
        </member>
        <member name="M:GT.Net.TransportPacket.IncrementRefCount(System.ArraySegment{System.Byte})">
            <summary>
            Increment the reference count on the provided segment.
            </summary>
            <param name="segment">the referenced segment</param>
        </member>
        <member name="M:GT.Net.TransportPacket.DecrementRefCount(System.ArraySegment{System.Byte})">
            <summary>
            Decrement the reference count on the provided segment.
            </summary>
            <param name="segment">the referenced segment</param>
        </member>
        <member name="M:GT.Net.TransportPacket.IsManagedSegment(System.ArraySegment{System.Byte})">
            <summary>
            This method is only meant for testing purposes.
            </summary>
            <param name="segment">the segment</param>
            <returns>true if the segment is a valid packet segment</returns>
        </member>
        <member name="M:GT.Net.TransportPacket.PoolIndex(System.UInt32)">
            <summary>
            Return the approopriate pool for a buffer of length <see cref="!:segLength"/>.
            </summary>
            <param name="segLength"></param>
            <returns></returns>
        </member>
        <member name="M:GT.Net.TransportPacket.TestingPoolIndex(System.UInt32)">
            <summary>
            This is public for testing purposes only.
            </summary>
            <param name="segLength"></param>
        </member>
        <member name="M:GT.Net.TransportPacket.TestingDiscardPools">
            <summary>
            This is public for testing purposes only.
            </summary>
        </member>
        <member name="P:GT.Net.TransportPacket.Length">
            <summary>
            Return the number of bytes in this packet.
            </summary>
        </member>
        <member name="P:GT.Net.TransportPacket.MinSegmentSize">
            <summary>
            The smallest length allocated for a segment (not including the
            internal segment header).  This is expected to be a power of 2.
            </summary>
        </member>
        <member name="P:GT.Net.TransportPacket.MaxSegmentSize">
            <summary>
            The maximum length allocated for a segment (not including the
            internal segment header).  This is expected to be a power of 2.
            </summary>
        </member>
        <member name="T:GT.Net.TransportPacket.ReadStream">
            <summary>
            A destructive read stream on a packet. This stream is not seekable,
            and as such, Length and Position don't actually have to work as
            might be expected (i.e., Position records the number of bytes retrieved
            from the stream, and length is the total number of bytes available since
            the stream was created).  For this stream, Length and Position are
            *relatively* correct, but not absolutely correct.  That is,
            Length - Position will return the correct number of bytes available,
            but Length will not necessarily be the packet's *original* length,
            nor Position the number of bytes retrieved from this stream.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.ReadStream.activeOffset">
            <summary>
            An index into <see cref="F:GT.Net.TransportPacket.ReadStream.activeSegment"/>, relative to 
            <see cref="F:GT.Net.TransportPacket.ReadStream.activeSegment"/>'s <see cref="P:System.ArraySegment`1.Offset"/>.
            If &gt;= 0, then we are currently processing a segment.  If &lt; 0, then
            we are not currently processing a segment.
            </summary>
        </member>
        <member name="F:GT.Net.TransportPacket.ReadStream.activeSegment">
            <summary>
            The segment being actively processed.
            </summary>
        </member>
        <member name="T:GT.Net.TransportPacket.WriteStream">
            <summary>
            A writeable stream on to a packet.  This stream will grow the packet
            as necessary; users must ensure they call <see cref="M:GT.Net.TransportPacket.WriteStream.Flush"/> to
            append any new data.
            </summary>
        </member>
        <member name="T:GT.Utils.WrappedStream">
            <remarks>
            A stream with a fixed capacity.  Useful for debugging or message processing.
            </remarks>
        </member>
        <member name="T:GT.Utils.ArrayStream`1">
            <remarks>
            A stream on an array.
            </remarks>
        </member>
        <member name="T:GT.GaussianRandomNumberGenerator">
            <summary>
            A random number generator for gaussian values.
            This generator uses the polar transformation of the Box-Muller transformation, 
            as described at http://www.taygeta.com/random/gaussian.html.
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.uniformGenerator">
            <summary>
            The generator of uniform random values
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.mustGenerate">
            <summary>
            Track the usage status of the n1 and n2 values.  If true, then
            they must be regenerated; if false, then n2 is still valid.
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.mean">
            <summary>
            The mean and standard deviations
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.deviation">
            <summary>
            The mean and standard deviations
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.n1">
            <summary>
            The two sample values.
            </summary>
        </member>
        <member name="F:GT.GaussianRandomNumberGenerator.n2">
            <summary>
            The two sample values.
            </summary>
        </member>
        <member name="M:GT.GaussianRandomNumberGenerator.#ctor(System.Double,System.Double)">
            <summary>
            Create a new instance with specified mean and standard deviation.
            </summary>
            <param name="mean">the mean</param>
            <param name="deviation">the standard deviation</param>
        </member>
        <member name="M:GT.GaussianRandomNumberGenerator.#ctor(System.Double,System.Double,System.Random)">
            <summary>
            Create a new instance with specified mean and standard deviation
            using a configured generator of uniform random values.
            </summary>
            <param name="mean">the mean</param>
            <param name="deviation">the standard deviation</param>
            <param name="uniformGenerator">a generator of uniform random values</param>
        </member>
        <member name="M:GT.GaussianRandomNumberGenerator.NextDouble">
            <summary>
            Return a random value on N(mean, deviation).
            </summary>
            <returns></returns>
        </member>
        <member name="M:GT.GaussianRandomNumberGenerator.GenerateGaussianSamples">
            <summary>
            Gnerate two gaussian samples.
            </summary>
        </member>
        <member name="T:GT.GMC.GMCMarshaller">
            <summary>
            A facade for performing compression and decompression.
            GMC has two parts: a template compressor that finds repeated structure and
            syntax elements between messages, and a within-message compressor that uses
            Ziv-Lempel to reduce the size of large messages.  The template compressor
            examines messages to find repeated sequences, which are assigned a code
            and entered into a dictionary; these codes are then used to replace other
            occurrences of the sequence in future messages.  The template compression
            takes three parts: identifying and creating a template, compressing the
            message, and announcing any new templates.
            </summary>
            <remarks>
            Note: the GMCMarshaller uses its own message container format, and does not 
            use the LWMCF.
            </remarks>
        </member>
        <member name="F:GT.GMC.GMCMarshaller.subMarshaller">
            <summary>
            GMC operates on the results from a different marshaller.
            This sub-marshaller is used to transform objects, etc. to bytes.
            </summary>
        </member>
        <member name="F:GT.GMC.GMCMarshaller.compressor">
            <summary>
            The compressor used for messages being sent by this user.
            </summary>
        </member>
        <member name="F:GT.GMC.GMCMarshaller.decompressors">
            <summary>
            The per-user decompressors used to decompress messages from other users
            (as keyed by a unique identifier).  Decompressors require being notified
            of the templates and announcements (new dictionary entries) from the other
            users' systems.
            </summary>
        </member>
        <member name="F:GT.GMC.GMCMarshaller.totalUncompressedBytes">
            Statistics
        </member>
        <member name="M:GT.GMC.GMCMarshaller.#ctor(GT.Net.IMarshaller)">
            <summary>Creates a new instance of GMC.  
            Typically GMC will function as a singleton for each client, 
            however, there are cases where the designer may wish to have a variety of GMCS.</summary>
            <param name="subMrshlr">the submarshaller to use for marshalling objects to bytes.</param>
        </member>
        <member name="M:GT.GMC.GMCMarshaller.RemoveUserID(System.Int32)">
            <summary>
            Removes the decompressors for a certain userID
            </summary>
            <param name="userID">The userID to remove</param>
        </member>
        <member name="M:GT.GMC.GMCMarshaller.Encode(System.Byte[])">
            <summary>
            Encode (compress) the provided byte array.
            </summary>
            <param name="bytes">the bytes to be compressed</param>
            <returns>a compressed message package that holds the compressed message along
            with any updates required for its processing.</returns>
        </member>
        <member name="M:GT.GMC.GMCMarshaller.TryDeflating(System.Byte[])">
            <summary>
            Try compressing the provided uncompressed packet.  Return the best
            result; this may actually be the uncompressed packet itself.
            </summary>
            <param name="uncompressedPacket">the uncmpressed packet</param>
            <returns>the possibly-compressed packet</returns>
        </member>
        <member name="M:GT.GMC.GMCMarshaller.TryInflating(System.Byte[])">
            <summary>
            Examine potentially-compressed packet and apply its decompression
            technique.  Assumes entire contents of bytes forms the packet.
            </summary>
            <param name="bytes">the possibly-compressed packet</param>
            <returns>a stream with the definitely-decompressed contents</returns>
        </member>
        <member name="M:GT.GMC.GMCMarshaller.Decode(System.Int32,System.Byte[])">
            <summary>
            Decode the provided byte array received from the user with unique
            identity <c>userId</c>.
            </summary>
            <param name="userId">the unique identity for the user</param>
            <param name="encodedBytes">the encoded message received</param>
            <returns></returns>
        </member>
        <member name="T:GT.GMC.GMCMarshaller.GMCWithinMessageCompression">
            <summary>
            Special key to indicate content type
            </summary>
        </member>
        <member name="T:GT.GMC.GMCMarshaller.GMCMessageKey">
            <summary>
            Special key to indicate types of content value
            </summary>
        </member>
        <member name="T:GT.Net.LeakyBucketTransport">
            <summary>
            The leaky bucket algorithm is a method for shaping traffic, modelled
            on a bucket with a maximum capacity that drains at a fixed rate 
            (# bytes for some time unit). Packets to be sent are
            added to the bucket (buffered) until the bucket overflows, and
            and subsequent packets are discarded until the bucket has drained
            sufficiently. The leaky bucket algorithm thus imposes a hard limit 
            on the data transmission rate.
            </summary>
        </member>
        <member name="F:GT.Net.LeakyBucketTransport.availableCapacity">
            <summary>
            The number of bytes available for sending for the remainder
            of the current time unit.
            </summary>
        </member>
        <member name="F:GT.Net.LeakyBucketTransport.timer">
            <summary>
            Tracks the elapsed time for the current time unit.
            </summary>
        </member>
        <member name="F:GT.Net.LeakyBucketTransport.bucketContents">
            <summary>
            The bucket contents
            </summary>
        </member>
        <member name="M:GT.Net.LeakyBucketTransport.#ctor(GT.Net.ITransport,System.UInt32,System.TimeSpan,System.UInt32)">
            <summary>
            Wrap the provided transport.  This leaky bucket allows up to <see cref="!:drainageAmount"/>
            bytes to be sent every <see cref="!:drainageTimeUnit"/> time units.  The bucket is
            configured to buffer up to <see cref="!:bucketCapacity"/> bytes.
            </summary>
            <param name="wrapped">the transport to be wrapped</param>
            <param name="drainageAmount">the number of bytes drained per drainage time unit</param>
            <param name="drainageTimeUnit">the time unit to reset the available drainage amount</param>
            <param name="bucketCapacity">the maximum capacity of this leaky bucket</param>
        </member>
        <member name="M:GT.Net.LeakyBucketTransport.CheckDrain">
            <summary>
            Check to see if we've passed the time unit.  If so, make more
            drainage space available.
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.MaximumCapacity">
            <summary>
            The capacity of the bucket, in bytes.  Packets to be sent are
            added to the bucket (buffered) until the bucket overflows, and
            and subsequent packets are discarded until the bucket drains
            sufficiently.
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.DrainRate">
            <summary>
            The drainage rate, in bytes per second
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.DrainageAmount">
            <summary>
            The number of bytes that drain per time unit
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.TimeUnit">
            <summary>
            The time period for assessing drainage.  That is, <see cref="P:GT.Net.LeakyBucketTransport.DrainageAmount"/>
            bytes is allowed to drain out per <see cref="P:GT.Net.LeakyBucketTransport.TimeUnit"/>.
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.AvailableCapacity">
            <summary>
            How many bytes are available to send during the remainder of this time unit?
            </summary>
        </member>
        <member name="P:GT.Net.LeakyBucketTransport.RemainingBucketCapacity">
            <summary>
            How much capacity remains in this bucket (in bytes)?
            </summary>
        </member>
        <member name="T:GT.Net.TokenBucketTransport">
            <summary>
            The token bucket algorithm is a method for shaping traffic.  Tokens, 
            representing some transmission capacity, are added to the bucket on a 
            periodic basis.  There is a maximum capacity.  Each byte sent requires
            available tokens in the bucket.  If there are no tokens available, 
            the packet is queued. The token bucket allows bursty traffic.
            Note that this implementation is expressed in <em>bytes</em> per second, and not
            packets per second.
            </summary>
        </member>
        <member name="F:GT.Net.TokenBucketTransport.capacity">
            <summary>
            The currently available capacity.
            </summary>
        </member>
        <member name="F:GT.Net.TokenBucketTransport.timer">
            <summary>
            Track the time elapsed since the last token-accumulation check.
            </summary>
        </member>
        <member name="F:GT.Net.TokenBucketTransport.queuedPackets">
            <summary>
            The packets that are queued for sending.
            </summary>
        </member>
        <member name="M:GT.Net.TokenBucketTransport.#ctor(GT.Net.ITransport,System.Single,System.UInt32)">
            <summary>
            Wrap the provided transport.
            </summary>
            <param name="wrapped">the transport to be wrapped</param>
            <param name="refillRate">the token refilling rate, in bytes per second</param>
            <param name="maximumCapacity">the maximum transmission capacity, expressed
            in bytes</param>
        </member>
        <member name="M:GT.Net.TokenBucketTransport.TrySending">
            <summary>
            Could throw an exception.
            </summary>
            <returns>true if all packets were sent, false if there are still some
                packets queued</returns>
        </member>
        <member name="P:GT.Net.TokenBucketTransport.RefillRate">
            <summary>
            The rate at which the bucket refills.
            This value is expressed in bytes per second.
            </summary>
        </member>
        <member name="P:GT.Net.TokenBucketTransport.MaximumCapacity">
            <summary>
            The maximum sustained capacity; this is the bucket maximum beyond which
            it cannot fill up any further.  This value is expressed in bytes.
            </summary>
        </member>
        <member name="P:GT.Net.TokenBucketTransport.AvailableCapacity">
            <summary>
            How many bytes are available to send at this very moment?
            </summary>
        </member>
        <member name="T:GT.Net.Reliability">
            <summary>Guarantees on message delivery.</summary>
        </member>
        <member name="F:GT.Net.Reliability.Unreliable">
            <summary>The selected transport need not guarantee reliable delivery.</summary>
        </member>
        <member name="F:GT.Net.Reliability.Reliable">
            <summary>The selected transport must guarantee reliable delivery.</summary>
        </member>
        <member name="T:GT.Net.Ordering">
            <summary>
            Guarantees or requirements for ordering of packets/messages. 
            If two packets are sent in a particular order, and both are
            received (see <see cref="T:GT.Net.Reliability"/>), does the transport
            guarantee that the packets will be received in that order?
            </summary>
        </member>
        <member name="F:GT.Net.Ordering.Unordered">
            <summary>There are no guarantees on packet order.</summary>
        </member>
        <member name="F:GT.Net.Ordering.Sequenced">
            <summary>Packets are received in order, but there may be duplicates.</summary>
        </member>
        <member name="F:GT.Net.Ordering.Ordered">
            <summary>Packets are received in order, and with no duplicates.</summary>
        </member>
        <member name="T:GT.Net.MessageAggregation">
            <summary>Can this message be aggregated?  This setting ties into 
            latency-sensitivity.</summary>
        </member>
        <member name="F:GT.Net.MessageAggregation.Aggregatable">
            <summary>This message can be saved, and sent depending on the 
            specified message ordering</summary>
        </member>
        <member name="F:GT.Net.MessageAggregation.Immediate">
            <summary>This message will be sent immediately, without worrying 
            about any saved-to-be-aggregated messages</summary>
        </member>
        <member name="F:GT.Net.MessageAggregation.FlushChannel">
            <summary>This message will flush all other saved-to-be-aggregated 
            messages on this channel out beforehand</summary>
        </member>
        <member name="F:GT.Net.MessageAggregation.FlushAll">
            <summary>This message will flush all other saved-to-be-aggregated 
            messages out beforehand</summary>
        </member>
        <member name="T:GT.Net.Freshness">
            <summary>
            Should receiving clients receive all messages sent on a channel or
            do they represent intermediate values only?  (This is only applicable with
            <see cref="F:GT.Net.MessageAggregation.Immediate"/>, since the other values of
            <see cref="T:GT.Net.MessageAggregation"/> cause the channels to be flushed upon send, 
            and thus there should be nothing in the channels.)
            </summary>
        </member>
        <member name="F:GT.Net.Freshness.IncludeAll">
            <summary>All messages are relevant and should be included.</summary>
        </member>
        <member name="F:GT.Net.Freshness.IncludeLatestOnly">
            <summary>Throw away old messages, including only the latest message.</summary>
        </member>
        <member name="T:GT.Net.MessageDeliveryRequirements">
            <summary>
            Describes the expected QoS requirements for a particular message.  These requirements override
            the defaults specified by the sending channel as described by a
            <see cref="T:GT.Net.ChannelDeliveryRequirements"/>.
            
            Note: users should pay close attention to the aggregation requirements!
            Any use of <see cref="F:GT.Net.MessageAggregation.Aggregatable"/> requires that the
            appliction <em>manually flush</em> the channel periodically.
            </summary>
        </member>
        <member name="M:GT.Net.MessageDeliveryRequirements.#ctor">
            <summary>
            A default constructor that uses the minimum requirements possible.
            </summary>
        </member>
        <member name="M:GT.Net.MessageDeliveryRequirements.#ctor(GT.Net.Reliability,GT.Net.MessageAggregation,GT.Net.Ordering)">
            <summary>
            A constructor for specifying the most common requirements.
            </summary>
            <param name="d">the minimum reliability requirement</param>
            <param name="a">the minimum aggregation requirement</param>
            <param name="o">the minimum ordering requirement</param>
        </member>
        <member name="M:GT.Net.MessageDeliveryRequirements.SelectTransport(System.Collections.Generic.IList{GT.Net.ITransport})">
            <summary>
            Select a transport meeting the requirements as specified by this instance.
            Assume that <see cref="!:candidates"/> is in a sorted order.
            </summary>
            <param name="candidates">the sorted list of available transports</param>
        </member>
        <member name="M:GT.Net.MessageDeliveryRequirements.MeetsRequirements(GT.Net.ITransport)">
            <summary>
            Test whether a candidate meets the requirements as specified by this instance.
            </summary>
            <param name="candidate">the transport to test</param>
        </member>
        <member name="P:GT.Net.MessageDeliveryRequirements.Reliability">
            <summary>
            Get/set the minimum reliability requirement
            </summary>
            <seealso cref="P:GT.Net.MessageDeliveryRequirements.Reliability"/>
        </member>
        <member name="P:GT.Net.MessageDeliveryRequirements.Ordering">
            <summary>
            Get/set the minimum ordering requirement
            </summary>
            <seealso cref="P:GT.Net.MessageDeliveryRequirements.Ordering"/>
        </member>
        <member name="P:GT.Net.MessageDeliveryRequirements.Aggregation">
            <summary>
            Get/set the minimum aggregation requirement
            </summary>
            <seealso cref="P:GT.Net.MessageDeliveryRequirements.Aggregation"/>
        </member>
        <member name="P:GT.Net.MessageDeliveryRequirements.MostStrict">
            <summary>
            An instance representing the most strict requirements possible.
            </summary>
        </member>
        <member name="P:GT.Net.MessageDeliveryRequirements.LeastStrict">
            <summary>
            An instance representing the least strict requirements possible.
            </summary>
        </member>
        <member name="T:GT.Net.ChannelDeliveryRequirements">
            <summary>
            Describes the expected QoS requirements for a channel.  These requirements form
            the default for any message sent on the configured channel; these defaults can
            be overridden on a per-message basis by providing a <see cref="T:GT.Net.MessageDeliveryRequirements"/>.
            
            Note: users should pay close attention to the aggregation requirements!
            Any use of MessageAggregation.Aggregatable requires periodically <em>manually flushing</em>
            the channel.
            </summary>
        </member>
        <member name="M:GT.Net.ChannelDeliveryRequirements.#ctor">
            <summary>
            A default constructor that specific the *LEAST* stringent possible values.
            </summary>
        </member>
        <member name="M:GT.Net.ChannelDeliveryRequirements.#ctor(GT.Net.Reliability,GT.Net.MessageAggregation,GT.Net.Ordering)">
            <summary>
            Constructor to set the 3 most common value
            </summary>
            <param name="d">the required reliability</param>
            <param name="a">the desired aggregation</param>
            <param name="o">the required ordered</param>
        </member>
        <member name="M:GT.Net.ChannelDeliveryRequirements.SelectTransport(System.Collections.Generic.IList{GT.Net.ITransport})">
            <summary>
            Select a transport meeting the requirements as specified by this instance. 
            Assume that <c>transports</c> is in a sorted order.
            </summary>
            <param name="transports">the sorted list of available transports</param>
        </member>
        <member name="M:GT.Net.ChannelDeliveryRequirements.MeetsRequirements(GT.Net.ITransport)">
            <summary>
            Test whether a transport meets the requirements as specified by this instance
            </summary>
            <param name="transport">the transport to test</param>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.Reliability">
            <summary>
            Get/set the reliability
            </summary>
            <seealso cref="P:GT.Net.ChannelDeliveryRequirements.Reliability"/>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.Ordering">
            <summary>
            Get/set the ordering value.
            </summary>
            <seealso cref="P:GT.Net.ChannelDeliveryRequirements.Ordering"/>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.Aggregation">
            <summary>
            Get/set the aggregation value.
            </summary>
            <seealso cref="P:GT.Net.ChannelDeliveryRequirements.Aggregation"/>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.Freshness">
            <summary>
            Get/set the freshness value.
            </summary>
            <seealso cref="P:GT.Net.ChannelDeliveryRequirements.Freshness"/>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.MostStrict">
            <summary>A descriptor with the strictest possible requirements.</summary>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.LeastStrict">
            <summary>A descriptor with the least strict requirements possible.</summary>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.AwarenessLike">
            <summary>
            A descriptor for awareness data such as telepointers: such messages can be
            aggregated <b>for short time periods</b>, they should not be received
            out-of-order, but it's ok if they're lost (unreliable).  The application
            should ensure that such channels are either periodically flushed or have
            a lower ping time, to ensure these changes are pushed out.  Only the last 
            item placed in the channel will actually be sent 
            (Freshness.IncludeLatestOnly), replacing any previous values.
            </summary>
            <remarks>
            We have changed this definition slightly from Dyck et al. to actually
            recommend aggregation rather than being sent immediately.
            </remarks>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.ChatLike">
            <summary>
            A descriptor for chat messages: such messages should be received in order
            (e.g., after any previous chat messages) and must be received.  
            Such messages should be sent right away.
            </summary>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.CommandsLike">
            <summary>A descriptor for command messages: such messages should be received in order
            (as they may depend on the results of previous commands) and must be received.  
            They should be sent right away.</summary>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.SessionLike">
            <summary>A descriptor for session notification messages: such messages must be 
            received but may be received out of order.  They should cause all other pending
            messages to be sent first.</summary>
        </member>
        <member name="P:GT.Net.ChannelDeliveryRequirements.Data">
            <summary>A descriptor for data messages: such messages must be 
            received and in a strict order.  <em>NOTE: data messages can be
            aggregated and require the channel to be periodically flushed.</em></summary>
        </member>
        <member name="T:GT.Net.SpecificTransportRequirement">
            <summary>
            A special <see cref="T:GT.Net.MessageDeliveryRequirements"/> variant to
            request a specific transport.
            </summary>
        </member>
        <member name="F:GT.Net.SpecificTransportRequirement.transport">
            <summary>
            The specific transport requestd
            </summary>
        </member>
        <member name="M:GT.Net.SpecificTransportRequirement.#ctor(GT.Net.ITransport)">
            <summary>
            Create an instance of an MDR that requires a specific transport.
            </summary>
            <param name="t">the specific transport to require</param>
        </member>
        <member name="M:GT.Net.SpecificTransportRequirement.#ctor(GT.Net.ITransport,GT.Net.MessageAggregation)">
            <summary>
            Create an instance of an MDR that requires a specific transport.
            </summary>
            <param name="t">the specific transport to require</param>
            <param name="aggr">the aggregation required</param>
        </member>
        <member name="M:GT.Net.SpecificTransportRequirement.MeetsRequirements(GT.Net.ITransport)">
            <summary>
            Verify whether the provided transport is the specific transport
            as required by this instance.
            </summary>
            <param name="candidate">the candidate transport</param>
            <returns>true if the candidate is the specific transport</returns>
        </member>
        <member name="T:GT.Net.CommunicationStatisticsObserver`1">
            <summary>
             A class gathering statistics on the networking behaviour of a 
             communicator (a GT Client or a GT Server).
            </summary>
        </member>
        <member name="M:GT.Net.CommunicationStatisticsObserver`1.Reset">
            <summary>
            Reset the values that are updated each tick.
            </summary>
        </member>
        <member name="M:GT.Net.CommunicationStatisticsObserver`1.Snapshot">
            <summary>
            Take a snapshot of the accumulated values.
            </summary>
        </member>
        <member name="P:GT.Net.StatisticsSnapshot.ConnexionCount">
            <summary>
            How many connexions does the communicator have open?
            </summary>
        </member>
        <member name="T:GT.GMC.TemplateBasedCompressor">
            <summary>
            Represents a sequence of template-based compressors.  Currently a staged pipeline of:
            <list>
            <item>a trie compressor that replaces sequences in a message with corresponding
            subsequence of the template</item>
            <item>a dictionary compressor that replaces the template-subsequence indices with
            byte-based shortcuts</item>
            <item>a Huffman encoder that remaps the byte-based shortcuts</item>
            </list>
            </summary>
        </member>
        <member name="F:GT.GMC.TemplateBasedCompressor.frequenciesSent">
            <summary>
            Track whether the pending frequency updates in <c>frequencies</c> have been
            successfully sent.
            </summary>
        </member>
        <member name="F:GT.GMC.TemplateBasedCompressor.uses">
            <summary>
            Record how often has this instance been used?
            </summary>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.NoteTemplateUse">
            <summary>
            Note usage of this template.
            </summary>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.Check">
            <summary>
            Opportunity for maintenance.  If a template has been used enough, turn huffman encoding 
            on for it
            </summary>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.UpdatesAccepted">
            <summary>
            All updates (announcements, frequency changes) have been sent and
            received by the others.  Nil out all records to begin accumulation
            anew.
            </summary>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.UpdatesRejected">
            Any updates (announcements, frequency changes) were not sent and
            should be resent on subsequent messages.
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.HandleNewAnnouncement(System.Int16,System.UInt32,System.Byte)">
            <summary>
            Record the announcement of a new dictionary entry, to be added to
            the next outgoing message.
            </summary>
            <param name="longForm">The full trie identity</param>
            <param name="shortForm">The shortcut identity</param>
            <param name="templateId">Who the shortcut will be used with</param>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.HandleUpdatedFrequencies(System.Int16,System.UInt32[])">
            <summary>
            Record the announcement of a set of byte frequencies, to be added to
            the next outgoing message.
            </summary>
            <param name="templateId">the associated template</param>
            <param name="frequencies">the byte-usage frequencies</param>
        </member>
        <member name="M:GT.GMC.TemplateBasedCompressor.Decode(GT.GMC.CompressedMessagePackage)">
            <summary>
            Decompresses a message using the provided compressors.
            </summary>
            <param name="cmp">the details of the message to be decompressed</param>
            <returns>The decoded (uncompressed) message</returns>
        </member>
        <member name="P:GT.GMC.TemplateBasedCompressor.HuffmanEncoding">
            <summary>
            Return true if data should be huffman-encoded, false otherwise.
            </summary>
        </member>
        <member name="T:GT.Net.LargeObjectMarshaller">
            <summary>
            A marshaller that wraps another marshaller to break down large messages 
            into manageable chunks for the provided transport.  Each manageable chunk
            is called a fragment.  A message may be discarded if the underlying transport
            is sequenced and a fragment is received out of order or an intermediate fragment
            has been dropped), or if the message has passed out of the sequence window.
            </summary>
            <remarks>
            The LOM operates on the results from a different marshaller.
            This sub-marshaller is used to transform objects, etc. to bytes.
            The LOM uses the high bit of the MessageType byte to encode whether 
            a message has been fragmented.
            
            The LOM uses the <see cref="F:GT.Net.LWMCFv11.Descriptor">
            LWMCF v1.1 message container format</see>, regardless of the primitive message 
            container format used by the sub-marshaller.  When used with a LWMCF v1.1
            sub-marshaller, the LOM is able to optimize packet layout
            by removing the duplicate header.
            
            Each message is broken down as follows:
            <list>
            <item> if the message fits into a transport packet, then the message 
                is returned as-is:
                <pre>[byte:message-type] [byte:channelId] [uint32:packet-size] 
                    [bytes:original packet]</pre>
            </item>
            <item> if the message is the first fragment, then the high-bit is
                set on the message-type; the number of fragments is encoded using
                the adaptive <see cref="!:ByteUtils.EncodeLength(int)"/> format.
                <pre>[byte:message-type'] [byte:channelId] [uint32:packet-size] 
                    [byte:seqno] [bytes:encoded-#-fragments] [bytes:frag]</pre>
            </item>
            <item> for all subsequent fragments; seqno' = seqno | 128;
                the number of fragments is encoded using the adaptive 
                <see cref="!:ByteUtils.EncodeLength(int)"/> format.
                <pre>[byte:message-type'] [byte:channelId] [uint32:packet-size] 
                    [byte:seqno'] [bytes:encoded-fragment-#] [bytes:frag]</pre>
            </item>
             </list>
            </remarks>
        </member>
        <member name="F:GT.Net.LargeObjectMarshaller.subMarshaller">
            <summary>
            The submarshaller used for encoding messages into packets.
            </summary>
        </member>
        <member name="F:GT.Net.LargeObjectMarshaller._defaultWindowSize">
            <summary>
            The default window size to be used, if a window size is unspecified
            at creation time.
            </summary>
        </member>
        <member name="F:GT.Net.LargeObjectMarshaller.outgoingSeqNo">
            <summary>
            The sequence number for the next outgoing message on a particular transport
            </summary>
        </member>
        <member name="F:GT.Net.LargeObjectMarshaller.accumulatedReceived">
            <summary>
            Bookkeeping data for in-progress messages received.
            </summary>
        </member>
        <member name="P:GT.Net.LargeObjectMarshaller.WindowSize">
            <summary>
            The maximum number of messages maintained; messages that are not
            completed within this window are discarded.
            </summary>
        </member>
        <member name="T:GT.Net.ReliableSequences">
            <summary>
            Fragments sent using a reliable transport will always come through.
            Just gotta have faith.
            </summary>
        </member>
        <member name="T:GT.Net.FragmentedMessage">
            <summary>
            Represent a message being progressively reassembled from a set of packet
            fragments.  Because the fragments may come out of order, we support assembling
            a message when the number of fragments is unknown; this is less optimal, however.
            If a provided fragment is referenced, then we must call <see cref="M:GT.Net.TransportPacket.Retain"/>.
            Similarly on <see cref="M:GT.Net.FragmentedMessage.Assemble"/>, we must <see cref="M:GT.Net.TransportPacket.Dispose"/>.
            </summary>
        </member>
        <member name="M:GT.Net.FragmentedMessage.RecordFragment(System.UInt32,GT.Net.TransportPacket)">
            <summary>
            Record the fragment at the position.  If recorded, then
            must retain the fragment.
            </summary>
            <param name="fragNo"></param>
            <param name="frag"></param>
            <returns>true if the fragment hadn't been previously seen</returns>
        </member>
        <member name="T:GT.Net.SystemMessageType">
            <summary>Internal message types for SystemMessages to have.</summary>
        </member>
        <member name="F:GT.Net.SystemMessageType.ConnexionClosing">
            <summary>
            Sent when a connexion is about to be torn down.
            </summary>
        </member>
        <member name="F:GT.Net.SystemMessageType.IncompatibleVersion">
            <summary>
            The remote speaks an incompatible dialect.
            </summary>
        </member>
        <member name="T:GT.Net.MessageType">
            <summary>
            Possible message types for Messages to have.
            These values must fall between 0 to 127.
            Values 128 - 255 are reserved for marshaller uses.
            </summary>
        </member>
        <member name="F:GT.Net.MessageType.Binary">
            <summary>This message is a byte array</summary>
        </member>
        <member name="F:GT.Net.MessageType.Object">
            <summary>This message is an object</summary>
        </member>
        <member name="F:GT.Net.MessageType.String">
            <summary>This message is a string</summary>
        </member>
        <member name="F:GT.Net.MessageType.System">
            <summary>This message is for the system, and special</summary>
        </member>
        <member name="F:GT.Net.MessageType.Session">
            <summary>This message refers to a session</summary>
        </member>
        <member name="F:GT.Net.MessageType.Tuple1D">
            <summary>This message refers to a streaming 1-tuple</summary>
        </member>
        <member name="F:GT.Net.MessageType.Tuple2D">
            <summary>This message refers to a streaming 2-tuple</summary>
        </member>
        <member name="F:GT.Net.MessageType.Tuple3D">
            <summary>This message refers to a streaming 3-tuple</summary>
        </member>
        <member name="T:GT.Net.SessionAction">
            <summary>Session action performed.  We can add a lot more to this list.</summary>
        </member>
        <member name="F:GT.Net.SessionAction.Joined">
            <summary>This client is joining this session.</summary>
        </member>
        <member name="F:GT.Net.SessionAction.Lives">
            <summary>This client is part of this session.</summary>
        </member>
        <member name="F:GT.Net.SessionAction.Inactive">
            <summary>This client is inactive.</summary>
        </member>
        <member name="F:GT.Net.SessionAction.Left">
            <summary>This client is leaving this session.</summary>
        </member>
        <member name="T:GT.Net.GTCapabilities">
            <summary>
            Constants used within GT and its implementations.
            </summary>
        </member>
        <member name="T:GT.Net.ConnexionLifecycleNotification">
            <summary>
            Delegate specification for notification of some change in the lifecycle
            of <c>conn</c>.
            </summary>
            <param name="c">the associated communicator instance</param>
            <param name="conn">the actual connexion</param>
        </member>
        <member name="T:GT.Net.MessagesSentNotification">
            <summary>Notification of outgoing messages</summary>
            <param name="msgs">The outgoing messages.</param>
            <param name="list">The destinations for the messages</param>
            <param name="mdr">How the message is to be sent</param>
        </member>
        <member name="T:GT.Net.Communicator">
            <summary>
            A base-level class encompassing the commonalities between GT Client
            and GT Server instances.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Start">
            <summary>
            Start the instance.  Starting an instance may throw an exception on error.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Stop">
            <summary>
            Stop the instance.  Instances can be stopped multiple times.
            Stopping an instance may throw an exception on error.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Dispose">
            <summary>
            Dispose of any system resources that may be held onto by this
            instance.  There should never be an exception thrown.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Update">
            <summary>
            Run a cycle to process any pending events for the connexions or
            other related objects for this instance.  This method is <strong>not</strong> 
            re-entrant and should not be called from GT callbacks.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Sleep">
            <summary>
            Sleep for the <see cref="P:GT.Net.Communicator.TickInterval"/>.  Return false if the sleep 
            finished early, such as because some event caused the instance to wake early.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.Sleep(System.TimeSpan)">
            <summary>
            Sleep for the specified amount of time.  Return false if the sleep 
            finished early, such as because some event caused the instance to wake early.
            </summary>
            <param name="sleepTime">the amount of time to sleep</param>
        </member>
        <member name="M:GT.Net.Communicator.StartSeparateListeningThread">
            <summary>
            Starts a new thread that listens to periodically call 
            <see cref="M:GT.Net.Communicator.Update"/>.  This thread instance will be stopped
            on <see cref="M:GT.Net.Communicator.Stop"/> or <see cref="M:GT.Net.Communicator.Dispose"/>.
            The frequency between calls to <see cref="M:GT.Net.Communicator.Update"/> is controlled
            by the configuration's <see cref="P:GT.Net.BaseConfiguration.TickInterval"/>.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.StartListening">
            <summary>Starts an infinite loop to periodically call
            <see cref="M:GT.Net.Communicator.Update"/> based on the current <see cref="P:GT.Net.Communicator.TickInterval"/>.</summary>
        </member>
        <member name="M:GT.Net.Communicator.RemoveDeadConnexions">
            <summary>
            Process the connexions lists to remove dead connexions.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.RemovedConnexion(GT.Net.IConnexion)">
            <summary>
            Remove the connexion at the provided index.  Overrides of
            this method should remove any state associated with the connexion
            at the provided index.
            </summary>
            <param name="cnx">the connexion being removed</param>
        </member>
        <member name="M:GT.Net.Communicator.NotifyTick">
            <summary>
            Notify any listeners to the <see cref="E:GT.Net.Communicator.Tick"/> event that this
            instance has seen a tick of <see cref="M:GT.Net.Communicator.Update"/>.
            </summary>
        </member>
        <member name="M:GT.Net.Communicator.NotifyMessageReceived(GT.Net.Message,GT.Net.IConnexion,GT.Net.ITransport)">
            <summary>Handle a message that was received from some connexion.</summary>
            <param name="m">The message.</param>
            <param name="cnx">Which client sent it.</param>
            <param name="t">How the message was sent</param>
        </member>
        <member name="E:GT.Net.Communicator.ErrorEvent">
            <summary>Occurs when there are errors on the network.</summary>
        </member>
        <member name="E:GT.Net.Communicator.ConnexionAdded">
            <summary>
            Triggered whenever a new connexion is added to this instance.
            </summary>
        </member>
        <member name="E:GT.Net.Communicator.ConnexionRemoved">
            <summary>
            Triggered whenever a new connexion is removed from this
            instance (e.g., all of the connexion's transports have been
            removed, rendering the remote incommunicable).
            </summary>
        </member>
        <member name="E:GT.Net.Communicator.Tick">
            <summary>Invoked each cycle of the server.</summary>
        </member>
        <member name="E:GT.Net.Communicator.MessageSent">
            <summary>Invoked each time a message is sent.</summary>
        </member>
        <member name="E:GT.Net.Communicator.MessageReceived">
            <summary>Invoked each time a message is received.</summary>
        </member>
        <member name="E:GT.Net.Communicator.SessionMessageReceived">
            <summary>Invoked each time a session message is received.</summary>
        </member>
        <member name="E:GT.Net.Communicator.StringMessageReceived">
            <summary>Invoked each time a string message is received.</summary>
        </member>
        <member name="E:GT.Net.Communicator.ObjectMessageReceived">
            <summary>Invoked each time a object message is received.</summary>
        </member>
        <member name="E:GT.Net.Communicator.BinaryMessageReceived">
            <summary>Invoked each time a binary mesage is received.</summary>
        </member>
        <member name="P:GT.Net.Communicator.Connexions">
            <summary>
            Return the list of current connexions.  This list may include 
            inactive or now-dead connexions; it is the caller's responsibility 
            to check the status of the connexion before use.  This method may
            return the live list used by this instance; the caller should be
            aware that any GT actions may cause this list to be changed from
            underneath the caller.
            </summary>
        </member>
        <member name="P:GT.Net.Communicator.Marshaller">
            <summary>
            Return the marshaller configured for this client.
            </summary>
        </member>
        <member name="P:GT.Net.Communicator.TickInterval">
            <summary>
            Returns the interval to wait between calls to <see cref="M:GT.Net.Communicator.Update"/>
            in <see cref="M:GT.Net.Communicator.StartListening"/>.
            </summary>
        </member>
        <member name="P:GT.Net.Communicator.PingInterval">
            <summary>
            Returns the interval to wait between pings.
            </summary>
        </member>
        <member name="P:GT.Net.Communicator.Active">
            <summary>
            Return true if the instance has been started (<see cref="M:GT.Net.Communicator.Start"/>)
            and neither stopped nor disposed (<see cref="M:GT.Net.Communicator.Stop"/> and 
            <see cref="M:GT.Net.Communicator.Dispose"/>).
            </summary>
        </member>
        <member name="P:GT.Net.Communicator.Guid">
            <summary>
            Return this instance's globally unique identifier (GUID).
            The GUID can be changed only when the instance is inactive.
            </summary>
        </member>
        <member name="T:GT.Net.BaseConfiguration">
            <summary>
            The configuration objects are used to encode the user's policy choices 
            and classes implementing those choices, separating them from the mechanisms 
            required to implement the different policies.
            </summary>
        </member>
        <member name="M:GT.Net.BaseConfiguration.Compare(GT.Net.ITransport,GT.Net.ITransport)">
            <summary>
            Default transport orderer: orders by reliability, then sequencing, then delay.
            </summary>
            <param name="x">first transport</param>
            <param name="y">second transport</param>
            <returns>-1 if x &lt; y, 0 if they're equivalent, and 1 if x &gt; y</returns>
        </member>
        <member name="M:GT.Net.BaseConfiguration.ConfigureTransport(GT.Net.ITransport)">
            <summary>
            Provide an opportunity to change configuration parameters or even wrap 
            or replace a transport instance.
            </summary>
            <param name="t">the transport to configure</param>
            <returns>the possibly reconfigured or replaced transport</returns>
        </member>
        <member name="P:GT.Net.BaseConfiguration.PingInterval">
            <summary>
            The time between pings to clients.  This must be greater than 0.
            </summary>
        </member>
        <member name="P:GT.Net.BaseConfiguration.TickInterval">
            <summary>
            The time between server ticks.  This must be greater than 0.
            </summary>
        </member>
        <member name="T:GT.Net.SummaryErrorCode">
            <summary>
            An actionable code describing the error.
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.UserException">
            <summary>
            An exception was raised in an user-provided event handler
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.RemoteUnavailable">
            <summary>
            A remote side could not be communicated with.
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.MessagesCannotBeSent">
            <summary>
            A collection of messages could not be sent to the remote;
            these messages will not be resent.
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.InvalidIncomingMessage">
            <summary>
            An incoming message was in an invalid format and could not be
            decoded.
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.TransportBacklogged">
            <summary>
            A transport cannot cope with the traffic being directed to
            it and any pending traffic is being backed up.
            </summary>
        </member>
        <member name="F:GT.Net.SummaryErrorCode.Configuration">
            <summary>
            There was a configuration problem in a component.
            </summary>
        </member>
        <member name="T:GT.Net.ErrorSummary">
            <summary>
            Represents a summary of an error or warning situation that has occurred
            during GT execution.
            </summary>
        </member>
        <member name="M:GT.Net.ErrorSummary.LogTo(Common.Logging.ILog)">
            <summary>
            Log this instance to the provided logger.
            </summary>
            <param name="log"></param>
        </member>
        <member name="T:GT.Net.ErrorEventNotication">
            <summary>Notification of an error event on a connexion.</summary>
            <param name="summary">A summary of the error event.</param>
        </member>
        <member name="T:GT.Net.MessageHandler">
            <summary>Notification of a message having been sent or received.</summary>
            <param name="m">The message.</param>
            <param name="client">The source or destination of the message</param>
            <param name="transport">How the message was sent</param>
        </member>
        <member name="T:GT.Net.TransportLifecyleNotification">
            <summary>
            Notification that a transport was either added or removed.
            </summary>
            <param name="connexion"></param>
            <param name="newTransport"></param>
        </member>
        <member name="T:GT.Net.PingingNotification">
            <summary>
            Notification of a ping having been sent.
            </summary>
            <param name="transport">The transport used for the ping</param>
            <param name="sequence">The sequence number for this ping.</param>
        </member>
        <member name="T:GT.Net.PingedNotification">
            <summary>
            Notification of a response to a ping request.
            </summary>
            <param name="transport">The transport from which the ping was received</param>
            <param name="sequence">The sequence number of the ping</param>
            <param name="roundtrip">The round-trip time between issuing the ping to 
            the response being received</param>
        </member>
        <member name="T:GT.Net.IConnexion">
            <summary>
            Connexions represent a communication connection between a client and server.
            Using a connexion, a client can send a message or messages to a server, and
            vice-versa.  Note that the <see cref="M:System.IDisposable.Dispose"/> method
            does not perform a friendly shutdown, such that the opposite side will be 
            notified of the closing of this connexion; use <see cref="M:GT.Net.IConnexion.ShutDown"/> instead.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.Update">
            <summary>
            Run a cycle to process any pending events for the transports and
            other related objects for this instance.  This method is <strong>not</strong> 
            re-entrant and should not be called from GT callbacks.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.Ping">
            <summary>
            Ping the other side to determine delay; also serves as act as a keep-alive.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.ShutDown">
            <summary>
            Close this connexion, while telling the other side.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.Dispose">
            <summary>
            Close this connection immediately.  See <see cref="M:GT.Net.IConnexion.ShutDown"/>
            for a kinder variant that notifies the other side.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.Send(GT.Net.Message,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a message using these parameters.  At least one of <c>mdr</c> and
            <c>cdr</c> are expected to be specified (i.e., be non-null).</summary>
            <param name="msg">The message to send.</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.IConnexion.Send(System.Collections.Generic.IList{GT.Net.Message},GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a set of messages using these parameters.  
            At least one of <c>mdr</c> and <c>cdr</c> are expected to be specified 
            (i.e., be non-null).</summary>
            <param name="msgs">The message to send.</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.IConnexion.Send(System.Byte[],System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a byte array on <see cref="!:channelId"/>.
            At least one of <c>mdr</c> and <c>cdr</c> are expected to be specified 
            (i.e., be non-null).</summary>
            <param name="buffer">The byte array to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.IConnexion.Send(System.String,System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a string on <see cref="!:channelId"/>.
            At least one of <c>mdr</c> and <c>cdr</c> are expected to be specified 
            (i.e., be non-null).</summary>
            <param name="s">The string to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.IConnexion.Send(System.Object,System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Sends an object on <see cref="!:channelId"/>.
            At least one of <c>mdr</c> and <c>cdr</c> are expected to be specified 
            (i.e., be non-null).</summary>
            <param name="o">The object to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.IConnexion.Flush">
            <summary>
            Flush all pending messages on this connexion.
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.FlushChannel(System.Byte)">
            <summary>
            Flush all pending messages for the specified channel on this connexion.
            </summary>
            <param name="channelId">the channel for flushing</param>
        </member>
        <member name="M:GT.Net.IConnexion.AddTransport(GT.Net.ITransport)">
            <summary>
            Add the provided transport to this connexion.
            </summary>
            <param name="t">the transport to add</param>
        </member>
        <member name="M:GT.Net.IConnexion.RemoveTransport(GT.Net.ITransport)">
            <summary>
            Remove the provided transport from this connexion's list.
            </summary>
            <param name="t">the transport to remove</param>
            <returns>true if the transport was found, false if the specified
            transport was not registered with this instance</returns>
        </member>
        <member name="M:GT.Net.IConnexion.Marshal(GT.Net.Message,GT.Net.ITransportDeliveryCharacteristics)">
            <summary>
            A supplementary interface to be implemented by all <see cref="T:GT.Net.IConnexion"/>,
            used by packet schedulers to marshal
            </summary>
        </member>
        <member name="M:GT.Net.IConnexion.SendPacket(GT.Net.ITransport,GT.Net.TransportPacket)">
            <summary>
            A supplementary interface for use by <see cref="T:GT.Net.IPacketScheduler"/>.
            Sends a packet on the provided transport.
            </summary>
            <param name="transport">the transport to be sent</param>
            <param name="packet">the packet to be sent</param>
            <returns>true if successfully sent, false otherwise</returns>
            <exception cref="T:GT.Net.TransportError">thrown on send error; such errors are
                fatal and indicate the transport can no longer be used</exception>
        </member>
        <member name="M:GT.Net.IConnexion.FindTransport(GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>
            Find a transport that meets the requirements specified by
            <see cref="!:mdr"/> or <see cref="!:cdr"/>.
            </summary>
            <param name="mdr">the requirements specific with the message; this overrides
                the channel requirements</param>
            <param name="cdr">the requirements associated with the channel</param>
            <returns>a transport that meets these requirements</returns>
            <exception cref="T:GT.Net.NoMatchingTransport">thrown if there is no matching transport</exception>
        </member>
        <member name="P:GT.Net.IConnexion.Delay">
            <summary>
            The (possibly / likely) smoothed delay seen for this connexion (in milliseconds).
            </summary>
        </member>
        <member name="P:GT.Net.IConnexion.Active">
            <summary>
            Return true if this instance is active
            </summary>
        </member>
        <member name="P:GT.Net.IConnexion.Identity">
            <summary>The server-unique identity of this client</summary>
        </member>
        <member name="E:GT.Net.IConnexion.ErrorEvents">
            <summary>
            Notification of fatal errors occurring on the connexion.
            </summary>
        </member>
        <member name="E:GT.Net.IConnexion.MessageReceived">
            <summary>Triggered when a message is received.</summary>
        </member>
        <member name="E:GT.Net.IConnexion.MessageSent">
            <summary>Triggered when a message is sent.</summary>
        </member>
        <member name="E:GT.Net.IConnexion.TransportAdded">
            <summary>
            Triggered when a new transport is added to this instance.
            </summary>
        </member>
        <member name="E:GT.Net.IConnexion.TransportRemoved">
            <summary>
            Triggered when a transport is removed from this instance
            (e.g., because it was disconnected).
            </summary>
        </member>
        <member name="E:GT.Net.IConnexion.PingRequested">
            <summary>
            Triggereed when a ping has just been sent.
            </summary>
        </member>
        <member name="E:GT.Net.IConnexion.PingReplied">
            <summary>
            Triggered when a ping response has ben received.
            </summary>
        </member>
        <member name="P:GT.Net.IConnexion.Transports">
            <summary>
            The list of currently-connected transports.  Transports are ordered as
            determined by this connexion's owner (see <c>BaseConfguration</c>).
            Callers should not modify this list, and use <see cref="M:GT.Net.IConnexion.AddTransport(GT.Net.ITransport)"/>
            and <see cref="M:GT.Net.IConnexion.RemoveTransport(GT.Net.ITransport)"/> instead.
            </summary>
        </member>
        <member name="F:GT.Net.BaseConnexion.identity">
            <summary>
            The server's unique identifier for this connexion; this
            identifier is only unique within the server's client
            group and is not globally unique.
            </summary>
        </member>
        <member name="M:GT.Net.BaseConnexion.NotifyError(GT.Net.ErrorSummary)">
            <summary>Occurs when there is an error.</summary>
        </member>
        <member name="M:GT.Net.BaseConnexion.Ping">
            <summary>Ping the other side to determine delay, as well as act as a keep-alive.</summary>
        </member>
        <member name="M:GT.Net.BaseConnexion.Update">
            <summary>A single tick of the connexion.</summary>
        </member>
        <member name="M:GT.Net.BaseConnexion.AttemptReconnect(GT.Net.ITransport)">
            <summary>
            Provide an opportunity to reconnect the provided transport.
            </summary>
            <param name="transport">the disconnected transport</param>
            <returns>the replacement transport if successful, null otherwise.</returns>
        </member>
        <member name="M:GT.Net.BaseConnexion.NewPacketReceived(GT.Net.TransportPacket,GT.Net.ITransport)">
            <summary>
            Handles a new packet
            </summary>
        </member>
        <member name="M:GT.Net.BaseConnexion._marshaller_MessageAvailable(System.Object,GT.Net.MessageEventArgs)">
            <summary>
            Notification that a completed message was unmarshalled
            </summary>
            <param name="marshaller"></param>
            <param name="mea"></param>
        </member>
        <member name="M:GT.Net.BaseConnexion.HandleNewMessage(GT.Net.Message,GT.Net.ITransport)">
            <summary>
            A new non-system message has been received and unmarshalled.
            Subclasses can override this message; for example, a subclass
            may choose to defer notifying of new messages until a later time.
            </summary>
            <param name="message"></param>
            <param name="transport"></param>
        </member>
        <member name="M:GT.Net.BaseConnexion.NotifyMessageReceived(GT.Net.Message,GT.Net.ITransport)">
            <summary>
            Trigger the <see cref="E:GT.Net.BaseConnexion.MessageReceived"/> event.
            </summary>
            <param name="message"></param>
            <param name="transport"></param>
        </member>
        <member name="M:GT.Net.BaseConnexion.HandleSystemMessage(GT.Net.SystemMessage,GT.Net.ITransport)">
            <summary>
            Handle a newly-received system message.
            </summary>
            <param name="message"></param>
            <param name="transport"></param>
            <exception cref="T:GT.Net.ConnexionClosedException">if the connexion is closing</exception>
            <exception cref="T:GT.Net.TransportError">on some transport problem</exception>
        </member>
        <member name="M:GT.Net.BaseConnexion.FindTransport(GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <remarks>
            This implementation effectively delegates the resolving to the MDR and
            CDR instances.
            </remarks>
        </member>
        <member name="M:GT.Net.BaseConnexion.Marshal(GT.Net.Message,GT.Net.ITransportDeliveryCharacteristics)">
            <summary>
            Marshal the provided message.  Primarily intended for use by 
            <see cref="T:GT.Net.IPacketScheduler"/> implementations.
            </summary>
            <param name="m"></param>
            <param name="tdc"></param>
            <returns>the marshalled result</returns>
        </member>
        <member name="M:GT.Net.BaseConnexion.Send(System.Byte[],System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a byte array on <see cref="!:channelId"/>.</summary>
            <param name="buffer">The byte array to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.BaseConnexion.Send(System.String,System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a string on <see cref="!:channelId"/>.</summary>
            <param name="s">The string to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.BaseConnexion.Send(System.Object,System.Byte,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Sends an bject on <see cref="!:channelId"/>.</summary>
            <param name="o">The object to send</param>
            <param name="channelId">The channel to be sent on</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.BaseConnexion.Send(GT.Net.Message,GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a message.</summary>
            <param name="message">The message to send.</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.BaseConnexion.Send(System.Collections.Generic.IList{GT.Net.Message},GT.Net.MessageDeliveryRequirements,GT.Net.ChannelDeliveryRequirements)">
            <summary>Send a set of messages.</summary>
            <param name="messages">The messages to send.</param>
            <param name="mdr">Requirements for this particular message; may be null.</param>
            <param name="cdr">Requirements for the message's channel.</param>
        </member>
        <member name="M:GT.Net.BaseConnexion.FastpathSendMessage(GT.Net.ITransport,GT.Net.Message)">
            <summary>
            Short-circuit operation to send a message with no fuss, no muss, and no waiting.
            This should be used very sparingly.
            </summary>
            <param name="transport">Where to send it</param>
            <param name="msg">What to send</param>
        </member>
        <member name="E:GT.Net.BaseConnexion.ErrorEvents">
            <summary>
            Notification of fatal errors occurring on the connexion.
            </summary>
        </member>
        <member name="E:GT.Net.BaseConnexion.MessageReceived">
            <summary>Triggered when a message is received.</summary>
        </member>
        <member name="E:GT.Net.BaseConnexion.MessageSent">
            <summary>Triggered when a message is sent.</summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.Marshaller">
            <summary>
            Return the appropriate marshaller for this connexion.
            </summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.Transports">
            <summary>
            Retrieve the transports associated with this connexion.
            Intended only for statistical use.
            </summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.Identity">
            <summary>
            Return the server-unique identity for the client represented 
            by *this connexion*.
            </summary>
            <seealso cref="P:GT.Net.BaseConnexion.SendingIdentity"/>
        </member>
        <member name="P:GT.Net.BaseConnexion.ClientGuid">
            <summary>
            Return the globally unique identifier for the client
            represented by this connexion.
            </summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.SendingIdentity">
            <summary>
            Return the identity to be used for sending messages across this connexion.
            For a connexion representing a client's interface to the server 
            (i.e., a GT.Net.ServerConnexion), this is the server's id for 
            this connexion to the client (and should be the same as 
            <see cref="P:GT.Net.BaseConnexion.Identity"/>).  For a connexion representing a server's
            interface to a client (i.e., a GT.Net.ClientConnexion), this is the 
            server's id for itself.
            </summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.Delay">
            <summary>Average latency on this connexion.</summary>
        </member>
        <member name="P:GT.Net.BaseConnexion.Active">
            <summary>
            Is this client dead?
            </summary>
        </member>
        <member name="T:GT.Net.TransportFactory`1">
            <summary>
            A useful class for testing some of the acceptors and connectors
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:GT.GMC.EnumExceptionType">
            <summary>A compression exception</summary>
        </member>
        <member name="F:GT.GMC.EnumExceptionType.MissingTemplate">
            <summary>A template is missing</summary>
        </member>
        <member name="F:GT.GMC.EnumExceptionType.MissingAnnouncement">
            <summary>An announcement is missing</summary>
        </member>
        <member name="F:GT.GMC.EnumExceptionType.MissingFrequencyTable">
            <summary>A frequency table is missing</summary>
        </member>
        <member name="T:GT.GMC.MissingInformationException">
            <summary>More information is required to decompress this data.</summary>
        </member>
        <member name="F:GT.GMC.MissingInformationException.ExceptionType">
            <summary>The information type that is missing</summary>
        </member>
        <member name="F:GT.GMC.MissingInformationException.Template">
            <summary>The template identifier that is missing</summary>
        </member>
        <member name="F:GT.GMC.MissingInformationException.UserID">
            <summary>The identity of the user who has the missing information</summary>
        </member>
        <member name="F:GT.GMC.MissingInformationException.IDs">
            <summary>A list of missing announcements that are required</summary>
        </member>
        <member name="M:GT.GMC.MissingInformationException.#ctor">
            <summary>Creates a new, blank, MissingInformationException.</summary>
        </member>
        <member name="M:GT.GMC.MissingInformationException.#ctor(System.String)">
            <summary>Creates a new, blank, MissingInformationException.</summary>
        </member>
        <member name="M:GT.GMC.MissingInformationException.#ctor(System.String,System.Exception)">
            <summary>Creates a new, blank, MissingInformationException.</summary>
        </member>
        <member name="M:GT.GMC.MissingInformationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor needed for serialization 
            when exception propagates from a remoting server to the client.</summary>
        </member>
        <member name="T:GT.GMC.CompressedMessagePackage">
            <summary>
            An object passed back after compression.
            Contains any templates, announcements, frequency tables, or other information
            needed to decompress data from this particular compressor.
            </summary>
        </member>
        <member name="M:GT.GMC.CompressedMessagePackage.EstimatedMessageLength">
            <summary>
            Return the estimated length in bytes for encoding purposes.
            </summary>
            <returns>number of estimated bytes required</returns>
        </member>
        <member name="T:GT.GMC.GeneralMessageCompressor">
            <summary>
            Implements the general message compressor as described by 
            C Gutwin, C Fedak, M Watson, J Dyck, T Bell (2006).  Improving network efficiency 
            in real-time groupware with general message compression.  In Proc of the Conf on Computer
            Supported Cooperative Work (CSCW), 119--128.  doi:10.1145/1180875.1180894.
            &lt;http://hci.usask.ca/publications/2006/compression.pdf&gt;
            </summary>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.#ctor">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.ConstructTemplate(System.Byte[])">
            <summary>
            if we know a template that we would like to construct, we can give it to the Handler, 
            and it will add it.  
            </summary>
            <param name="template"></param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.AddTemplate(System.Byte[],System.Int16)">
            <summary>
            Adds a template to a specified location.  Replaces an existing template.
            </summary>
            <param name="template">the template value</param>
            <param name="templateId">the template identifier</param>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.SetMessagesSaved(System.Int32)">
            <summary>
            Set the number of messages to be saved for comparison when generating new templates.
            A new template is created when the last N messages are not well-compressed.
            </summary>
            <param name="number"></param>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.CheckTemplates">
            <summary>
            Provide opportunity for any maintenance.
            </summary>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.Encode(System.Byte[])">
            <summary>
            Compresses the message as best it can.   If the compression is above the set ratio, then 
            we label it as a candidate template and test to see if would make a good template.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.EncodeWith(System.Int32,System.Byte[])">
            <summary>
            Compresses a message using a specific template.
            </summary>
            <param name="templateId">the template to be used</param>
            <param name="message">the message to encode</param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.Decode(GT.GMC.CompressedMessagePackage,System.Int32)">
            <summary>
            Decode the provided message using the specified template
            </summary>
            <param name="cmp">the message package to be decompressed</param>
            <param name="userId">the user from which the encoded message was received</param>
            <returns>The decoded (uncompressed) message</returns>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.FindBestEncoding(System.Byte[])">
            <summary>
            Find the best compression for a message using existing messages
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:GT.GMC.GeneralMessageCompressor.ShouldGenerateNewTemplate(System.Byte[])">
            <summary>
            Check if the provided candidate would make a good template
            FIXME: Why are we throwing the template rep away?
            </summary>
            <param name="templateCandidate">the template</param>
            <returns></returns>
        </member>
        <member name="P:GT.GMC.GeneralMessageCompressor.HuffmanEncoding">
            <summary>
            Return true if data should be huffman-encoded, false otherwise.whether huffman encoding should be used.
            Enabled by default.
            </summary>
        </member>
        <member name="P:GT.GMC.GeneralMessageCompressor.TotalTemplates">
            returns total templates 
        </member>
        <member name="P:GT.GMC.GeneralMessageCompressor.TotalAnnouncements">
            <summary>
            Number of announcements that have been made
            </summary>
        </member>
        <member name="P:GT.GMC.GeneralMessageCompressor.TotalTemplateSize">
            In bytes, the size of the templates 
        </member>
        <member name="T:GT.Utils.BitUtils">
            <summary>
            A set of utility functions relating to bits.
            </summary>
        </member>
        <member name="F:GT.Utils.BitUtils.HighestBitLookupTable256">
            <summary>
            A lookup table to return the position of the highest bit set
            for numbers on [0,256].  Taken from  Sean Anderson's 
            <a href="http://www-graphics.stanford.edu/~seander/bithacks.html">
            BitWiddling Hacks</a>.
            </summary>
        </member>
        <member name="M:GT.Utils.BitUtils.HighestBitSet(System.Byte)">
            <summary>
            Returns the position of the highest bit set in the provided value.
            Note: number of bits required is this number + 1.
            Taken from  Sean Anderson's 
            <a href="http://www-graphics.stanford.edu/~seander/bithacks.html">
            BitWiddling Hacks</a>.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GT.Utils.BitUtils.HighestBitSet(System.UInt32)">
            <summary>
            Returns the position of the highest bit set in the provided value.
            Note: number of bits required is this number + 1.
            Taken from  Sean Anderson's 
            <a href="http://www-graphics.stanford.edu/~seander/bithacks.html">
            BitWiddling Hacks</a>.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:GT.Utils.BitUtils.IsPowerOf2(System.UInt32)">
            <summary>
            Verify whether the provided value is a power of 2.
            Taken from  Sean Anderson's 
            <a href="http://www-graphics.stanford.edu/~seander/bithacks.html">
            BitWiddling Hacks</a>.
            </summary>
            <returns>true if the value is a power of 2, false otherwise.
            Note that this implementation considers 0 to not be a power of 2.</returns>
        </member>
        <member name="M:GT.Utils.BitUtils.RoundUpToPowerOf2(System.UInt32)">
            <summary>
            Round up the provided value to the nearest power of 2.
            Taken from  Sean Anderson's 
            <a href="http://www-graphics.stanford.edu/~seander/bithacks.html">
            BitWiddling Hacks</a>.
            </summary>
        </member>
        <member name="T:GT.Utils.BitTuple">
            <summary>
            A growable list of bits, intended to be compatible with <see cref="T:System.Collections.BitArray"/>.
            </summary>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor">
            <summary>
            Create a new instance with 0 bits.
            </summary>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Int32)">
            <summary>
            Create a new instance with initial size of <see cref="!:setBits"/> bits.
            </summary>
            <param name="setBits">the initial size of the bit tuple</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new bit tuple with <see cref="!:setBits"/> allocated (and zero'd) 
            and space for <see cref="!:estimatedBits"/>.
            </summary>
            <param name="setBits">number of bits to be set</param>
            <param name="estimatedBits">estimate for initially allocated space</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Collections.BitArray)">
            <summary>
            Create a new instance based on the provided <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="bs">the source of bits</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Collections.BitArray,System.Int32)">
            <summary>
            Create a new instance based on the first <see cref="!:numBits"/> bits
            of the provided <see cref="T:System.Collections.BitArray"/> instance.
            </summary>
            <param name="bs">the source of bits</param>
            <param name="numBits">the number of bits of <see cref="!:source"/> to be used</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Boolean[])">
            <summary>
            Create an instance using the provided bools (true = 1, false = 0).
            </summary>
            <param name="bits">the source of bits</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Boolean[],System.Int32)">
            <summary>
            Create an instance using the first <see cref="!:numBits"/> bits
            from the provided bools (true = 1, false = 0).
            </summary>
            <param name="source">the source of bits</param>
            <param name="numBits">the number of bits of <see cref="!:source"/> to be used</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Byte[])">
            <summary>
            Create a new instance, initialized using the provided byte array.
            The bytes are interepreted in the same manner as that accepted by
            <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="source">the source of bits</param>
        </member>
        <member name="M:GT.Utils.BitTuple.#ctor(System.Byte[],System.Int32)">
            <summary>
            Create a new instance, initialized using the first <see cref="!:numBits"/>
            bits from the provided byte array. The bytes are interepreted in the 
            same manner as that accepted by <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <param name="source">the source of bits</param>
            <param name="numBits">the number of bits of <see cref="!:source"/> to be used</param>
        </member>
        <member name="M:GT.Utils.BitTuple.Add(System.Boolean)">
            <summary>
            Append the provided value.
            </summary>
            <param name="bit">the new bit</param>
        </member>
        <member name="M:GT.Utils.BitTuple.AddAll(System.Collections.BitArray)">
            <summary>
            Append the provided bits.
            </summary>
            <param name="bits">the new bits</param>
        </member>
        <member name="M:GT.Utils.BitTuple.AddAll(System.Boolean[])">
            <summary>
            Append the provided bits.
            </summary>
            <param name="bits">the new bits</param>
        </member>
        <member name="M:GT.Utils.BitTuple.ToBitArray">
            <summary>
            Return the equivalent <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GT.Utils.BitTuple.ToArray">
            <summary>
            Return the equivalent byte array; note that any filler bits 
            required to meet a full byte are zero.  The format matches the
            bits as encoded by <see cref="T:System.Collections.BitArray"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GT.Utils.BitTuple.Length">
            <summary>
            Return the number of bits encoded in this instance.
            </summary>
        </member>
        <member name="P:GT.Utils.BitTuple.Item(System.Int32)">
            <summary>
            Return the bit at the provided index.
            </summary>
            <param name="index">the index</param>
            <returns>the corresponding bit</returns>
            <exception cref="T:System.ArgumentException">thrown on an invalid index</exception>
        </member>
    </members>
</doc>
